<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C#的网络编程Socket</title>
    <link href="/2022/05/17/C-%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BSocket/"/>
    <url>/2022/05/17/C-%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BSocket/</url>
    
    <content type="html"><![CDATA[<p><del>又是个难点傲</del></p><span id="more"></span><p>在日常生活中人们沟通是通过电话,那么流程是什么呢？</p><ol><li>双方都有手机这个物品</li><li>双方都有手机号码</li><li>其中有一方知道另一方的手机号码</li><li>你们说的是双方都能听懂的语言</li></ol><p>在网络上通讯也类似</p><ol><li>双方都得有Sockte 也就是手机（通常以用户的客服端，连接应用程序的服务器这种形式）</li><li>双方地有手机号码 就是IP地址和端口号</li><li>其中有一方知道另一方的手机号码 也就是IP地址和端口号</li><li>你们说的是双方都能听懂的语言 网络协议 一般常用的是TCP UPC协议</li></ol><p> PS:附加点</p><ol><li>TCP协议需要经过“3次握手”后确认服务器端能有空闲接收客服端的数据时才会发送 <br>优点：数据传输不会丢失稳定 缺点：效率底下</li><li>UPC协议直接简单粗暴，直接往服务器端发送数据不管服务器是否能接收<br>优点：效率高 缺点：数据易丢失不稳定</li></ol><h3 id="上面不过是理论-实际上的会复杂不少"><a href="#上面不过是理论-实际上的会复杂不少" class="headerlink" title="上面不过是理论 实际上的会复杂不少"></a>上面不过是理论 实际上的会复杂不少</h3><h3 id="实际上客服端至始至终只有一个发送数据的SocKte-而服务器有最低2个Sockte-一个负责监听-一个负责把客服端发送的请求传输到需要的端口（引路人）"><a href="#实际上客服端至始至终只有一个发送数据的SocKte-而服务器有最低2个Sockte-一个负责监听-一个负责把客服端发送的请求传输到需要的端口（引路人）" class="headerlink" title="实际上客服端至始至终只有一个发送数据的SocKte 而服务器有最低2个Sockte 一个负责监听 一个负责把客服端发送的请求传输到需要的端口（引路人）"></a>实际上客服端至始至终只有一个发送数据的SocKte 而服务器有最低2个Sockte 一个负责监听 一个负责把客服端发送的请求传输到需要的端口（引路人）</h3><h2 id="那么开始流程模拟"><a href="#那么开始流程模拟" class="headerlink" title="那么开始流程模拟"></a>那么开始流程模拟</h2><h2 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h2><h2 id="首先创建Socket-对象-初始化时确定-IP格式是V4还是V6-数据流还是数据报-采用的协议"><a href="#首先创建Socket-对象-初始化时确定-IP格式是V4还是V6-数据流还是数据报-采用的协议" class="headerlink" title="首先创建Socket 对象 初始化时确定 IP格式是V4还是V6 数据流还是数据报 采用的协议"></a>首先创建Socket 对象 初始化时确定 IP格式是V4还是V6 数据流还是数据报 采用的协议</h2><h2 id="然后创建IPAddres-对象-x3D-IPAddres-Any-或IPAddres-Parse-IP地址字符串-IP地址就传入对象了"><a href="#然后创建IPAddres-对象-x3D-IPAddres-Any-或IPAddres-Parse-IP地址字符串-IP地址就传入对象了" class="headerlink" title="然后创建IPAddres 对象 &#x3D; IPAddres.Any 或IPAddres.Parse(IP地址字符串) IP地址就传入对象了"></a>然后创建IPAddres 对象 &#x3D; IPAddres.Any 或IPAddres.Parse(IP地址字符串) IP地址就传入对象了</h2><h2 id="再将IPEndPoint-对象-x3D-new-IP对象-端口号int类型-将端口号对象初始化"><a href="#再将IPEndPoint-对象-x3D-new-IP对象-端口号int类型-将端口号对象初始化" class="headerlink" title="再将IPEndPoint 对象 &#x3D; new (IP对象,端口号int类型) 将端口号对象初始化"></a>再将IPEndPoint 对象 &#x3D; new (IP对象,端口号int类型) 将端口号对象初始化</h2><h2 id="获得IP地址和端口号-绑定监听-监听的Socket对象-Bind-传入端口对象-端口对象自带了IP地址"><a href="#获得IP地址和端口号-绑定监听-监听的Socket对象-Bind-传入端口对象-端口对象自带了IP地址" class="headerlink" title="获得IP地址和端口号 绑定监听 监听的Socket对象.Bind(传入端口对象) 端口对象自带了IP地址"></a>获得IP地址和端口号 绑定监听 监听的Socket对象.Bind(传入端口对象) <del>端口对象自带了IP地址</del></h2><h2 id="开始监听-监听的Socket对象-Listen-Listen-可以传入一个int类型设置同时间最大进入数量-也就是排队"><a href="#开始监听-监听的Socket对象-Listen-Listen-可以传入一个int类型设置同时间最大进入数量-也就是排队" class="headerlink" title="开始监听 监听的Socket对象.Listen(); Listen()可以传入一个int类型设置同时间最大进入数量 也就是排队"></a>开始监听 监听的Socket对象.Listen(); <del>Listen()可以传入一个int类型设置同时间最大进入数量 也就是排队</del></h2><h2 id="现在已经有了个负责监视有没有人来的Sokcet了-如果随时有可能来一个客服端访问-就需要一个负责引路-也就是把服务端连接到客服端的Socket-的Socket"><a href="#现在已经有了个负责监视有没有人来的Sokcet了-如果随时有可能来一个客服端访问-就需要一个负责引路-也就是把服务端连接到客服端的Socket-的Socket" class="headerlink" title="现在已经有了个负责监视有没有人来的Sokcet了 如果随时有可能来一个客服端访问 就需要一个负责引路(也就是把服务端连接到客服端的Socket)的Socket"></a>现在已经有了个负责监视有没有人来的Sokcet了 如果随时有可能来一个客服端访问 就需要一个负责引路(也就是把服务端连接到客服端的Socket)的Socket</h2><h2 id="负责监视的Socket对象调用Accept-方法-返回一个负责连接的Socket"><a href="#负责监视的Socket对象调用Accept-方法-返回一个负责连接的Socket" class="headerlink" title="负责监视的Socket对象调用Accept()方法 返回一个负责连接的Socket"></a>负责监视的Socket对象调用Accept()方法 返回一个负责连接的Socket</h2><h2 id="负责连接的Socket也不知道你什么时候下线-当客服端发送空的时候也许就下线了-所以会一直接收客服端发送的数据-接收连接客服端实际发送数据大小的方法-Receive-我是单次接收最大值的Byte数组，但发过来的数据也在里面-返回int值-代表本次实际接收的大小"><a href="#负责连接的Socket也不知道你什么时候下线-当客服端发送空的时候也许就下线了-所以会一直接收客服端发送的数据-接收连接客服端实际发送数据大小的方法-Receive-我是单次接收最大值的Byte数组，但发过来的数据也在里面-返回int值-代表本次实际接收的大小" class="headerlink" title="负责连接的Socket也不知道你什么时候下线(当客服端发送空的时候也许就下线了) 所以会一直接收客服端发送的数据 接收连接客服端实际发送数据大小的方法 Receive(我是单次接收最大值的Byte数组，但发过来的数据也在里面) 返回int值 代表本次实际接收的大小"></a>负责连接的Socket也不知道你什么时候下线(当客服端发送空的时候也许就下线了) 所以会一直接收客服端发送的数据 接收连接客服端实际发送数据大小的方法 Receive(我是单次接收最大值的Byte数组，但发过来的数据也在里面) 返回int值 代表本次实际接收的大小</h2><h2 id="获得实际发送的字节数后-把客服端发送过来的数据转为S对于类型-任君处置"><a href="#获得实际发送的字节数后-把客服端发送过来的数据转为S对于类型-任君处置" class="headerlink" title="获得实际发送的字节数后 把客服端发送过来的数据转为S对于类型 任君处置"></a>获得实际发送的字节数后 把客服端发送过来的数据转为S对于类型 任君处置</h2><p>PS:如果服务器也想发数据 麻烦调用负责连接的Socket的Send方法并将需要发送的数据转换成byte数组传入方法</p><h2 id="客服端"><a href="#客服端" class="headerlink" title="客服端:"></a>客服端:</h2><h2 id="与服务器端不同，客服端只有一个负责联系的Socket"><a href="#与服务器端不同，客服端只有一个负责联系的Socket" class="headerlink" title="与服务器端不同，客服端只有一个负责联系的Socket"></a>与服务器端不同，客服端只有一个负责联系的Socket</h2><h2 id="首先创建负责联系的Socket-对象-初始化时确定-IP格式是V4还是V6-数据流还是数据报-采用的协议-与服务器端一致"><a href="#首先创建负责联系的Socket-对象-初始化时确定-IP格式是V4还是V6-数据流还是数据报-采用的协议-与服务器端一致" class="headerlink" title="首先创建负责联系的Socket 对象 初始化时确定 IP格式是V4还是V6 数据流还是数据报 采用的协议 与服务器端一致"></a>首先创建负责联系的Socket 对象 初始化时确定 IP格式是V4还是V6 数据流还是数据报 采用的协议 与服务器端一致</h2><h2 id="然后创建IPAddres-对象-x3D-IPAddres-Parse-IP地址字符串-IP地址就传入对象了-与服务器端一致"><a href="#然后创建IPAddres-对象-x3D-IPAddres-Parse-IP地址字符串-IP地址就传入对象了-与服务器端一致" class="headerlink" title="然后创建IPAddres 对象 &#x3D;IPAddres.Parse(IP地址字符串) IP地址就传入对象了 与服务器端一致"></a>然后创建IPAddres 对象 &#x3D;IPAddres.Parse(IP地址字符串) IP地址就传入对象了 与服务器端一致</h2><h2 id="再将IPEndPoint-对象-x3D-new-IP对象-端口号int类型-将端口号对象初始化-与服务器一致"><a href="#再将IPEndPoint-对象-x3D-new-IP对象-端口号int类型-将端口号对象初始化-与服务器一致" class="headerlink" title="再将IPEndPoint 对象 &#x3D; new (IP对象,端口号int类型) 将端口号对象初始化 与服务器一致"></a>再将IPEndPoint 对象 &#x3D; new (IP对象,端口号int类型) 将端口号对象初始化 与服务器一致</h2><h2 id="获得IP地址和端口号绑定-建立服务器连接-联系的Socket对象Connect-传入端口对象-端口对象自带了IP地址"><a href="#获得IP地址和端口号绑定-建立服务器连接-联系的Socket对象Connect-传入端口对象-端口对象自带了IP地址" class="headerlink" title="获得IP地址和端口号绑定 建立服务器连接 联系的Socket对象Connect(传入端口对象); 端口对象自带了IP地址"></a>获得IP地址和端口号绑定 建立服务器连接 联系的Socket对象Connect(传入端口对象); <del>端口对象自带了IP地址</del></h2><h2 id="建立服务器连接成功后-即可调用负责联系的Socket对象的方法Send-并将需要发送的数据转换成byte数组传入方法-即可发送数据到服务器"><a href="#建立服务器连接成功后-即可调用负责联系的Socket对象的方法Send-并将需要发送的数据转换成byte数组传入方法-即可发送数据到服务器" class="headerlink" title="建立服务器连接成功后 即可调用负责联系的Socket对象的方法Send()并将需要发送的数据转换成byte数组传入方法 即可发送数据到服务器"></a>建立服务器连接成功后 即可调用负责联系的Socket对象的方法Send()并将需要发送的数据转换成byte数组传入方法 即可发送数据到服务器</h2><p>PS:如果客服端想接收服务器发送的数据 就需要用负责联系的Socket对象调用 Receive<br>负责连接的Socket也不知道服务器端什么时候发数据过来 所以会一直接收服务器端发送的数据 接收服务器端实际发送数据大小的方法 Receive(我是单次接收最大值的Byte数组，但发过来的数据也在里面) 返回int值 代表本次实际接收的大小</p><h2 id="Receive实际上的作用-官方说法是-从绑定接收数据-Socket-到缓冲区中"><a href="#Receive实际上的作用-官方说法是-从绑定接收数据-Socket-到缓冲区中" class="headerlink" title="Receive实际上的作用 官方说法是 从绑定接收数据 Socket 到缓冲区中"></a><del>Receive实际上的作用 官方说法是 从绑定接收数据 Socket 到缓冲区中</del></h2><h1 id="但↑面这一坨只能是理论，实际上情况会更复杂-比如说此时如果再来客服端连接服务器-上一个连接会被顶掉-那么只能和目前联系服务器的客服端联系了解决需要保存连接的IP地址和端口号还有负责连接的Socket对象才能保证还能找到之前客服端并进行联系"><a href="#但↑面这一坨只能是理论，实际上情况会更复杂-比如说此时如果再来客服端连接服务器-上一个连接会被顶掉-那么只能和目前联系服务器的客服端联系了解决需要保存连接的IP地址和端口号还有负责连接的Socket对象才能保证还能找到之前客服端并进行联系" class="headerlink" title="但↑面这一坨只能是理论，实际上情况会更复杂 比如说此时如果再来客服端连接服务器 上一个连接会被顶掉 那么只能和目前联系服务器的客服端联系了解决需要保存连接的IP地址和端口号还有负责连接的Socket对象才能保证还能找到之前客服端并进行联系"></a>但↑面这一坨只能是理论，实际上情况会更复杂 比如说此时如果再来客服端连接服务器 上一个连接会被顶掉 那么只能和目前联系服务器的客服端联系了<br>解决需要保存连接的IP地址和端口号还有负责连接的Socket对象<br>才能保证还能找到之前客服端并进行联系</h1><p>PS:如果你想做到群聊的效果就把消息发给所有联系过服务器的客服端即可</p><h1 id="那么如果你需要发送的不止字符串呢？"><a href="#那么如果你需要发送的不止字符串呢？" class="headerlink" title="那么如果你需要发送的不止字符串呢？"></a>那么如果你需要发送的不止字符串呢？</h1><h2 id="那么你就需要设定“协议了”"><a href="#那么你就需要设定“协议了”" class="headerlink" title="那么你就需要设定“协议了”"></a>那么你就需要设定“协议了”</h2><h2 id="把byte数组的第一位用来判断是什么类型-再将数据的byte添加到后面"><a href="#把byte数组的第一位用来判断是什么类型-再将数据的byte添加到后面" class="headerlink" title="把byte数组的第一位用来判断是什么类型 再将数据的byte添加到后面"></a>把byte数组的第一位用来判断是什么类型 再将数据的byte添加到后面</h2><h2 id="接收端只需要判断byte第一位是什么就知道发来的是什么并继续转换"><a href="#接收端只需要判断byte第一位是什么就知道发来的是什么并继续转换" class="headerlink" title="接收端只需要判断byte第一位是什么就知道发来的是什么并继续转换"></a>接收端只需要判断byte第一位是什么就知道发来的是什么并继续转换</h2><p>PS:大坑点</p><ol><li>Send方法有个关键的重载，决定发送的数据的长度 和指定套接字接收与发送数据的行为一般为none</li><li>发送方需要个OpenFileDialog 这个选择文件调用文件流读取转为byte发送出去，但接收方需要SaveFileDialog 但默认情况下貌似ShowDialog方法需要传入This关键字才能正常展示出</li></ol><table><thead><tr><th align="center">类</th><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Socket</td><td align="center">对象名.Connect(传入端口对象)</td><td align="center">与服务器建立连接</td></tr><tr><td align="center"></td><td align="center">对象名.Bind(传入端口对象)</td><td align="center">负责监听的Socket调用 绑定 用来监听有没有客服端进入此IP内的本端口</td></tr><tr><td align="center"></td><td align="center">对象名.RemoteEndPoint</td><td align="center">返回IP地址于端口号</td></tr><tr><td align="center"></td><td align="center">对象名.Send(传入需要发送的byte数组,可选发送起始,可选本次发送最多多少个字节，可选SocketFlages 是个枚举 指定套接字的发送与接收行为)</td><td align="center">发送byte数组</td></tr><tr><td align="center"></td><td align="center">对象名.Receive(负责接收的byte数组)</td><td align="center">返回实际接收的字节数 int类型</td></tr><tr><td align="center"></td><td align="center">对象名.Accept()</td><td align="center">返回一个负责连接的Socket</td></tr><tr><td align="center"></td><td align="center">对象名.Listen(我是最多排队人数)</td><td align="center">开始监听 并设置同时间进入时的排队队列人数</td></tr><tr><td align="center">IPAddress</td><td align="center">IPAddress.Parse(ip地址字符串)</td><td align="center">静态方法 传入ip地址字符串 返回一个IPAddress对象</td></tr><tr><td align="center">IPEndPoint</td><td align="center">构造函数(IP地址对象,int类型端口号)</td><td align="center">初始化端口对象</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#的进程与多线程</title>
    <link href="/2022/05/15/C-%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/05/15/C-%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>开学 我看谁不学</p><span id="more"></span><p><del>ps:又学到一个蛋疼的点了 默哀</del></p><h1 id="Process-进程类"><a href="#Process-进程类" class="headerlink" title="Process 进程类"></a>Process 进程类</h1><h2 id="众所周知，每个程序都会有进程，那么你可以通过进程类主动去调用进程打开应用或文件，也可以主动关闭进程"><a href="#众所周知，每个程序都会有进程，那么你可以通过进程类主动去调用进程打开应用或文件，也可以主动关闭进程" class="headerlink" title="众所周知，每个程序都会有进程，那么你可以通过进程类主动去调用进程打开应用或文件，也可以主动关闭进程"></a>众所周知，每个程序都会有进程，那么你可以通过进程类主动去调用进程打开应用或文件，也可以主动关闭进程</h2><table><thead><tr><th align="center">常用方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">.GetProcesses()</td><td align="center">静态方法 获取当前所有进程并返回一个Process类型的数组</td></tr><tr><td align="center">要关闭的Process.Kill()</td><td align="center">静态方法 杀掉进程</td></tr><tr><td align="center">对象名.StartInfo()</td><td align="center">获取需要传给 对象名.Start的属性值，需要传入一个ProcessStartInfo对象</td></tr><tr><td align="center">对象名.Start()</td><td align="center">打开文件 作用于.StartInfo传入的路径</td></tr></tbody></table><h3 id="PS-附加点-ProcessStarInfo对象初始化需要给予一个路径"><a href="#PS-附加点-ProcessStarInfo对象初始化需要给予一个路径" class="headerlink" title="PS:附加点 ProcessStarInfo对象初始化需要给予一个路径"></a>PS:附加点 ProcessStarInfo对象初始化需要给予一个路径</h3><h1 id="Thread-线程类"><a href="#Thread-线程类" class="headerlink" title="Thread 线程类"></a>Thread 线程类</h1><h2 id="Q-什么是线程？"><a href="#Q-什么是线程？" class="headerlink" title="Q: 什么是线程？"></a>Q: 什么是线程？</h2><h2 id="A-我想线程可以比喻成工地里的工人-而计算机处理的事情就是一个又一栋工人需要建造的楼层"><a href="#A-我想线程可以比喻成工地里的工人-而计算机处理的事情就是一个又一栋工人需要建造的楼层" class="headerlink" title="A: 我想线程可以比喻成工地里的工人,而计算机处理的事情就是一个又一栋工人需要建造的楼层"></a>A: 我想线程可以比喻成工地里的工人,而计算机处理的事情就是一个又一栋工人需要建造的楼层</h2><h2 id="Q-什么又是多线程？"><a href="#Q-什么又是多线程？" class="headerlink" title="Q: 什么又是多线程？"></a>Q: 什么又是多线程？</h2><h2 id="A-程序一般情况下都是单线程，接上面的例子来说，所有的工人都去建一个房子，那么工地的需求肯定不是一次建一栋，是有多个房子需要建，把所有工人继续分配全部同时开工的，这就是多线程"><a href="#A-程序一般情况下都是单线程，接上面的例子来说，所有的工人都去建一个房子，那么工地的需求肯定不是一次建一栋，是有多个房子需要建，把所有工人继续分配全部同时开工的，这就是多线程" class="headerlink" title="A: 程序一般情况下都是单线程，接上面的例子来说，所有的工人都去建一个房子，那么工地的需求肯定不是一次建一栋，是有多个房子需要建，把所有工人继续分配全部同时开工的，这就是多线程"></a>A: 程序一般情况下都是单线程，接上面的例子来说，所有的工人都去建一个房子，那么工地的需求肯定不是一次建一栋，是有多个房子需要建，把所有工人继续分配全部同时开工的，这就是多线程</h2><table><thead><tr><th align="center">常用方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Thread 线程对象名 &#x3D; new Thread(“我是线程执行的方法或委托”)</td><td align="center">thread的构造函数，创建线程时给予线程该做的事情</td></tr><tr><td align="center">对象名.Start()</td><td align="center">标记该线程已经准备好 CUP可以运行(什么时候运行是CUP自己判断的)</td></tr><tr><td align="center">对象名.Abort()</td><td align="center">关闭该线程(关闭后此线程无法再次启动)</td></tr><tr><td align="center">对象名.Sleep(里面写休眠时间单位为毫秒)</td><td align="center">休眠</td></tr></tbody></table><h3 id="PS-附加点"><a href="#PS-附加点" class="headerlink" title="PS:附加点"></a>PS:附加点</h3><h3 id="1-线程分为-前台线程-和后台线程-默认创建的线程是前台线程-如需要转换"><a href="#1-线程分为-前台线程-和后台线程-默认创建的线程是前台线程-如需要转换" class="headerlink" title="1. 线程分为 前台线程 和后台线程 默认创建的线程是前台线程 如需要转换"></a>1. 线程分为 前台线程 和后台线程 默认创建的线程是前台线程 如需要转换</h3><h3 id="对象名-IsBackground-x3D-true"><a href="#对象名-IsBackground-x3D-true" class="headerlink" title="对象名.IsBackground &#x3D; true"></a>对象名.IsBackground &#x3D; true</h3><h4 id="前台线程：所有前台线程都关闭时程序关闭"><a href="#前台线程：所有前台线程都关闭时程序关闭" class="headerlink" title="前台线程：所有前台线程都关闭时程序关闭"></a>前台线程：所有前台线程都关闭时程序关闭</h4><h4 id="后台线程：前台线程关闭后后台线程自动关闭"><a href="#后台线程：前台线程关闭后后台线程自动关闭" class="headerlink" title="后台线程：前台线程关闭后后台线程自动关闭"></a>后台线程：前台线程关闭后后台线程自动关闭</h4><h3 id="2-线程默认情况下无法跨线程干事"><a href="#2-线程默认情况下无法跨线程干事" class="headerlink" title="2. 线程默认情况下无法跨线程干事"></a>2. 线程默认情况下无法跨线程干事</h3><h4 id="也就是说你A线程如果想干的事情和B线程有关，会报异常"><a href="#也就是说你A线程如果想干的事情和B线程有关，会报异常" class="headerlink" title="也就是说你A线程如果想干的事情和B线程有关，会报异常"></a>也就是说你A线程如果想干的事情和B线程有关，会报异常</h4><h4 id="如果你执意如此，需要修改窗体的基类Control-的属性-CheckForIllegalCrossThreadCalls-x3D-false"><a href="#如果你执意如此，需要修改窗体的基类Control-的属性-CheckForIllegalCrossThreadCalls-x3D-false" class="headerlink" title="如果你执意如此，需要修改窗体的基类Control 的属性.CheckForIllegalCrossThreadCalls &#x3D; false;"></a>如果你执意如此，需要修改窗体的基类Control 的属性.CheckForIllegalCrossThreadCalls &#x3D; false;</h4><h3 id="3-如果线程执行的方法需要参数，方法的型参类型必须是Object-然后在Start-我是方法的实参，麻烦传这来-的括号里传入"><a href="#3-如果线程执行的方法需要参数，方法的型参类型必须是Object-然后在Start-我是方法的实参，麻烦传这来-的括号里传入" class="headerlink" title="3. 如果线程执行的方法需要参数，方法的型参类型必须是Object,然后在Start(我是方法的实参，麻烦传这来)的括号里传入"></a>3. 如果线程执行的方法需要参数，方法的型参类型必须是Object,然后在Start(我是方法的实参，麻烦传这来)的括号里传入</h3>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#的文件操作</title>
    <link href="/2022/04/20/C-%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/04/20/C-%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>学TNND 都给我学</p><span id="more"></span><h1 id="Path类-路径"><a href="#Path类-路径" class="headerlink" title="Path类 路径"></a>Path类 路径</h1><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Path.GetFileName</td><td align="center">获得一个路径里文件的文件名(包含扩展名)</td></tr><tr><td align="center">Path.GetFile.NameWithoutExtension</td><td align="center">获得一个路径里文件的文件名(不包含扩展名)</td></tr><tr><td align="center">Path.GetFilePath</td><td align="center">获得文件所在的全路径</td></tr><tr><td align="center">Path.GetRandomFileName</td><td align="center">获得文件夹的名字</td></tr><tr><td align="center">Path.Combine</td><td align="center">将2个字符串相连组成路径</td></tr></tbody></table><h1 id="File类-文件"><a href="#File类-文件" class="headerlink" title="File类 文件"></a>File类 文件</h1><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">File.Creat</td><td align="center">创建文件</td></tr><tr><td align="center">File.Delete</td><td align="center">删除文件</td></tr><tr><td align="center">File.Copy</td><td align="center">复制文件（需要传2个值，一个被复制的文件路径 一个复制到的路径<del>包括文件名</del>）</td></tr><tr><td align="center">File.Move</td><td align="center">剪切文件（需要传2个值，一个被剪切的文件路径 一个剪切到的路径<del>包括文件名</del>）</td></tr><tr><td align="center">File.ReadAllBytes</td><td align="center">打开一个2进制文件并读取，然后将读取内容返回为一个byet数组，最后关闭该文件</td></tr><tr><td align="center">File.WriteAllBytes</td><td align="center">创建一个新文件并写入指定的byte数组，然后关闭文件，如果文件存在即覆盖</td></tr><tr><td align="center">File.WriteAllText</td><td align="center">创建一个新文件并写入指定的字符串，然后关闭文件，如果文件存在即覆盖</td></tr><tr><td align="center">File.ReadAllText</td><td align="center">打开一个文本文件并读取然后关闭，读取的文本以string类型返回</td></tr><tr><td align="center">File.ReadAllLines</td><td align="center">打开一个文本文件并读取每一行然后关闭，读取的每一行以string类型的数组返回 读取的每一行文本以数组的一个元素表示</td></tr><tr><td align="center">File.WriteAllLines</td><td align="center">创建一个新的文本文件，写入一个字符串数组，每一个元素以行显示</td></tr></tbody></table><h2 id="附加点"><a href="#附加点" class="headerlink" title="附加点"></a>附加点</h2><h3 id="File-ReadAllBytes-返回的byte数组如何转换为字符串"><a href="#File-ReadAllBytes-返回的byte数组如何转换为字符串" class="headerlink" title="File.ReadAllBytes 返回的byte数组如何转换为字符串"></a>File.ReadAllBytes 返回的byte数组如何转换为字符串</h3><ul><li>Encoding.采用的编码格式.GetString(File.ReadAllBytes返回的Byte数组);<h4 id="如果方法内没有封装你需要的编码格式"><a href="#如果方法内没有封装你需要的编码格式" class="headerlink" title="如果方法内没有封装你需要的编码格式"></a>如果方法内没有封装你需要的编码格式</h4></li><li>Encoding.GetEncoding(“编码格式”).GetString(File.ReadAllBytes返回的Byte数组);<h3 id="将字符串转为byte数组赋给-File-WriteAllBytes"><a href="#将字符串转为byte数组赋给-File-WriteAllBytes" class="headerlink" title="将字符串转为byte数组赋给 File.WriteAllBytes"></a>将字符串转为byte数组赋给 File.WriteAllBytes</h3></li><li>声明byte数组 数组名 &#x3D; Encoding.想用的编码格式.GetBytes(需要转的字符串);<h3 id="如果你不想覆盖可以看看File-AppendAllLines-File-AppendAllText-File-AppendText"><a href="#如果你不想覆盖可以看看File-AppendAllLines-File-AppendAllText-File-AppendText" class="headerlink" title="如果你不想覆盖可以看看File.AppendAllLines File.AppendAllText File.AppendText"></a>如果你不想覆盖可以看看File.AppendAllLines File.AppendAllText File.AppendText</h3></li><li>加了Append 的方法在原来的基础上是不会覆盖的，只会在原有的内容上追加 如果不存在指定文件就会创建一个</li></ul><h1 id="FileStream类-文件流-操作字节"><a href="#FileStream类-文件流-操作字节" class="headerlink" title="FileStream类 文件流 操作字节"></a>FileStream类 文件流 操作字节</h1><h3 id="ps-她是普通的类和她的姐姐File不同，需要创建她的对象哟"><a href="#ps-她是普通的类和她的姐姐File不同，需要创建她的对象哟" class="headerlink" title="ps:她是普通的类和她的姐姐File不同，需要创建她的对象哟"></a>ps:她是普通的类和她的姐姐File不同，需要创建她的对象哟</h3><h2 id="File就如把你丢尽水缸里喝水，万一水多-文件大小-就会给你淹死-内存爆炸-所以我们需要一个可以自定义大小的水杯喝水-那就是我们的FileStream啦！"><a href="#File就如把你丢尽水缸里喝水，万一水多-文件大小-就会给你淹死-内存爆炸-所以我们需要一个可以自定义大小的水杯喝水-那就是我们的FileStream啦！" class="headerlink" title="File就如把你丢尽水缸里喝水，万一水多(文件大小)就会给你淹死(内存爆炸) 所以我们需要一个可以自定义大小的水杯喝水 那就是我们的FileStream啦！"></a>File就如把你丢尽水缸里喝水，万一水多(文件大小)就会给你淹死(内存爆炸) 所以我们需要一个可以自定义大小的水杯喝水 那就是我们的FileStream啦！</h2><h3 id="FileSteram-我是她的对象的名字-x3D-new-FileStream-操作文件的路径-FileMode-枚举类型提供的打开方式-FileAccess-枚举类型提供的读写"><a href="#FileSteram-我是她的对象的名字-x3D-new-FileStream-操作文件的路径-FileMode-枚举类型提供的打开方式-FileAccess-枚举类型提供的读写" class="headerlink" title="FileSteram 我是她的对象的名字 &#x3D; new FileStream (操作文件的路径,FileMode.枚举类型提供的打开方式,FileAccess.枚举类型提供的读写)"></a>FileSteram 我是她的对象的名字 &#x3D; new FileStream (操作文件的路径,FileMode.枚举类型提供的打开方式,FileAccess.枚举类型提供的读写)</h3><table><thead><tr><th align="center">常用方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">FileStream对象名.Read(装读取到字节的byte数组,开始处数int,要读取的字节数int)</td><td align="center">读取</td></tr><tr><td align="center">FileStream对象名.write(装要写入字节的byte数组,开始处数int,要写入的字节数int)</td><td align="center">写入</td></tr></tbody></table><h1 id="SteramReader类-读文本文件-SteramWrite-写文本文件"><a href="#SteramReader类-读文本文件-SteramWrite-写文本文件" class="headerlink" title="SteramReader类 读文本文件 SteramWrite 写文本文件"></a>SteramReader类 读文本文件 SteramWrite 写文本文件</h1><h1 id="Directory类-静态-文件夹（目录）"><a href="#Directory类-静态-文件夹（目录）" class="headerlink" title="Directory类 静态 文件夹（目录）"></a>Directory类 静态 文件夹（目录）</h1><p>PS:需要创建的文件夹如果已经存在那就不会生效</p><table><thead><tr><th align="center">常用方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">.CreateDirectory(“文件夹路径（想创建在哪里，叫什么名字）”)</td><td align="center">创建文件夹</td></tr><tr><td align="center">.Dete(“文件夹路径”可选的BOOL值)</td><td align="center">删除 如果删除的文件夹里有东西则需要填入bool值确认删除</td></tr><tr><td align="center">.Move(“原文件夹路径”,”新文件夹路径”)</td><td align="center">裁剪(你也可以吃饱了用来重命名)</td></tr><tr><td align="center">.GetFiles(“文件夹路径”,可选的筛选字符串)</td><td align="center">读取文件夹下文件的全路径</td></tr><tr><td align="center">.GetDirectories(“文件夹路径”)</td><td align="center">读取文件夹下文件夹的全路径</td></tr><tr><td align="center">.Exists(“文件夹路径”)</td><td align="center">判断文件夹是否存在 返回bool值</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>里氏转换</title>
    <link href="/2022/04/11/%E9%87%8C%E6%B0%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/04/11/%E9%87%8C%E6%B0%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="里氏转换其实也就2句话"><a href="#里氏转换其实也就2句话" class="headerlink" title="里氏转换其实也就2句话"></a>里氏转换其实也就2句话</h1><h1 id="1-子类可以赋给父类-换而言之如果一个地方需要传入父类作为参数，我们可以传入一个子类代替"><a href="#1-子类可以赋给父类-换而言之如果一个地方需要传入父类作为参数，我们可以传入一个子类代替" class="headerlink" title="1. 子类可以赋给父类:换而言之如果一个地方需要传入父类作为参数，我们可以传入一个子类代替"></a>1. 子类可以赋给父类:换而言之如果一个地方需要传入父类作为参数，我们可以传入一个子类代替</h1><h1 id="2-如果子类对象装在父类里，可以把父类转换为子类对象"><a href="#2-如果子类对象装在父类里，可以把父类转换为子类对象" class="headerlink" title="2. 如果子类对象装在父类里，可以把父类转换为子类对象"></a>2. 如果子类对象装在父类里，可以把父类转换为子类对象</h1><span id="more"></span><h2 id="附加知识点-类型判断"><a href="#附加知识点-类型判断" class="headerlink" title="附加知识点 类型判断"></a>附加知识点 类型判断</h2><ol><li>is 判断是否能转换为某个类型 如果能 返回 true 如果不能 返回 false</li></ol><ul><li>伪代码演示: string test0 &#x3D; “我是测试文本”;<br> if (test0 is int)<br>{<br>Console.write(“可以转换”)<br>}<br>else<br>{<br>Console.Write(“不能转换”)<br>}</li></ul><ol start="2"><li>as 判断类型是否能转换为某个类型 如果能 返回转换后的类型 如果不能 返回 null</li></ol><ul><li>伪代码演示: string n &#x3D; “我是测试文本”; int a &#x3D; n as int ; (这时候a会为null值)</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3基础</title>
    <link href="/2022/03/31/CSS3%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/31/CSS3%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><del>不过是写给自己的笔记罢了</del></p><span id="more"></span><h1 id="CSS的语法规范"><a href="#CSS的语法规范" class="headerlink" title="CSS的语法规范"></a>CSS的语法规范</h1><h2 id="规则由两个主要部分构成：选择器以及一条或多条声明"><a href="#规则由两个主要部分构成：选择器以及一条或多条声明" class="headerlink" title="规则由两个主要部分构成：选择器以及一条或多条声明"></a>规则由两个主要部分构成：选择器以及一条或多条声明</h2><h3 id="选择器是用于指定CSS样式的HTML标签，花括号内是给该标签设置的具体样式"><a href="#选择器是用于指定CSS样式的HTML标签，花括号内是给该标签设置的具体样式" class="headerlink" title="选择器是用于指定CSS样式的HTML标签，花括号内是给该标签设置的具体样式"></a>选择器是用于指定CSS样式的HTML标签，花括号内是给该标签设置的具体样式</h3><p>注意点</p><ul><li>在不创建新CSS的情况下 在在title标签 和 head标签之间 写style标签<del>在style标签内写CSS</del> </li><li>属性和值直接用英语下的:分隔 以键值对形式出现</li><li>多对 键值对 之间用英语状态下的; 分割<h3 id="选择器的作用就是根据不同需求把不同的标签选出来的东西，简而言之就是选择标签用的"><a href="#选择器的作用就是根据不同需求把不同的标签选出来的东西，简而言之就是选择标签用的" class="headerlink" title="选择器的作用就是根据不同需求把不同的标签选出来的东西，简而言之就是选择标签用的"></a>选择器的作用就是根据不同需求把不同的标签选出来的东西，简而言之就是选择标签用的</h3><img src="https://s2.loli.net/2022/04/01/EOUGYjXu69Kdvih.png" alt="选择器作用"><h3 id="选择器分为2大类-基础选择器和复合选择器"><a href="#选择器分为2大类-基础选择器和复合选择器" class="headerlink" title="选择器分为2大类 基础选择器和复合选择器"></a>选择器分为2大类 基础选择器和复合选择器</h3><h3 id="基础选择器是由单个选择器组成的"><a href="#基础选择器是由单个选择器组成的" class="headerlink" title="基础选择器是由单个选择器组成的"></a>基础选择器是由单个选择器组成的</h3><h3 id="基础选择器又包括-标签选择器、类选择器、id选择器、通配符选择器"><a href="#基础选择器又包括-标签选择器、类选择器、id选择器、通配符选择器" class="headerlink" title="基础选择器又包括:标签选择器、类选择器、id选择器、通配符选择器"></a>基础选择器又包括:标签选择器、类选择器、id选择器、通配符选择器</h3><h2 id="标签选择器就是以标签名作为选择器-并自动将样式应用到所有的该标签"><a href="#标签选择器就是以标签名作为选择器-并自动将样式应用到所有的该标签" class="headerlink" title="标签选择器就是以标签名作为选择器 并自动将样式应用到所有的该标签"></a>标签选择器就是以标签名作为选择器 并自动将样式应用到所有的该标签</h2><h2 id="类选择器-就是自己在样式标签里用英语状态下的-自定义类名-样式代码-想让哪一个或多个标签使用就在标签里用class-x3D-“自定义类名”最常用"><a href="#类选择器-就是自己在样式标签里用英语状态下的-自定义类名-样式代码-想让哪一个或多个标签使用就在标签里用class-x3D-“自定义类名”最常用" class="headerlink" title="类选择器 就是自己在样式标签里用英语状态下的 .自定义类名 { 样式代码 } 想让哪一个或多个标签使用就在标签里用class&#x3D;“自定义类名”最常用"></a>类选择器 就是自己在样式标签里用英语状态下的 .自定义类名 { 样式代码 } 想让哪一个或多个标签使用就在标签里用class&#x3D;“自定义类名”<del>最常用</del></h2></li><li>调用多个类选择器可以时用空格隔开添加别的类选择器 比如说我有个red 和 blue 这2个类选择器 我都添加到h1标签里应该是 class&#x3D; “red blue”<h2 id="id选择器-一般和js配合使用-类似于类选择器-声明-id名-样式代码-想让哪一个标签使用-就在标签内的id-x3D-id名"><a href="#id选择器-一般和js配合使用-类似于类选择器-声明-id名-样式代码-想让哪一个标签使用-就在标签内的id-x3D-id名" class="headerlink" title="id选择器(一般和js配合使用) 类似于类选择器 #声明 id名{ 样式代码 } 想让哪一个标签使用 就在标签内的id&#x3D;id名"></a>id选择器(一般和js配合使用) 类似于类选择器 #声明 id名{ 样式代码 } 想让哪一个标签使用 就在标签内的id&#x3D;id名</h2></li><li>不过和类选择器最大的不同是 id选择器具有唯一性 正常来说 整个HTML文件里只能调用一次 <h2 id="通配符选择器-用-声明-自定义名-样式代码-创建后自动应用到所有标签上"><a href="#通配符选择器-用-声明-自定义名-样式代码-创建后自动应用到所有标签上" class="headerlink" title="通配符选择器 用*声明 自定义名 { 样式代码 } 创建后自动应用到所有标签上"></a>通配符选择器 用*声明 自定义名 { 样式代码 } 创建后自动应用到所有标签上</h2></li></ul><h1 id="选择器总结"><a href="#选择器总结" class="headerlink" title="选择器总结"></a>选择器总结</h1><p><img src="https://s2.loli.net/2022/04/01/lIcaTZvNRHy61Uk.png" alt="Css选择器总结"></p><h1 id="字体系列-font"><a href="#字体系列-font" class="headerlink" title="字体系列 font"></a>字体系列 font</h1><h2 id="font-family-选择字体"><a href="#font-family-选择字体" class="headerlink" title="font-family 选择字体"></a>font-family 选择字体</h2><ul><li>字体的选择上可以输入字体的中文名 也可以输入 英文名 <del>一般中文名 和 多个单词组成的字体名 需要被单或双引号包括起来</del></li><li>如果一次选择了多个字体 首先判断系统是否有第一款字体 以此类推 如果没有字体可能会显示异常<h2 id="font-size-字体大小-最常用单位是px-像素-也可以百分比之类的"><a href="#font-size-字体大小-最常用单位是px-像素-也可以百分比之类的" class="headerlink" title="font-size 字体大小 最常用单位是px(像素) 也可以百分比之类的"></a>font-size 字体大小 最常用单位是px(像素) 也可以百分比之类的</h2></li><li>一般谷歌浏览器字体默认大小为16px</li><li>标题标签比较特殊 你如果想改body的字体默认大小不会影响到标题标签 需要单独给她设置大小<h2 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight 字体粗细"></a>font-weight 字体粗细</h2></li><li>属性值 normal 为默认的大小 数字表示为400</li><li>属性值 bold 为粗体 数字表示为700</li><li>属性值 bolder 为特粗体 </li><li>属性值 lighter 为细体</li><li>数字型赋值一般为 100-900 以百分 没有十位个位<h2 id="font-style-字体样式"><a href="#font-style-字体样式" class="headerlink" title="font-style 字体样式"></a>font-style 字体样式</h2></li><li>normal 为浏览器默认样式 <del>也就是正的</del> 一般用来吃饱了把斜体变成正体</li><li>italic 为斜体 一般用来花里胡哨把正体变成斜体<h2 id="font-属性的复合写法-快捷方便"><a href="#font-属性的复合写法-快捷方便" class="headerlink" title="font 属性的复合写法 (快捷方便)"></a>font 属性的复合写法 (快捷方便)</h2></li><li>复合写法必须按顺序 先 style 再 weight 然后 size&#x2F;line-height 最后 family 各属性空格隔开</li><li>如果不需要部分的属性可以不写 不写默认按默认值算 但不可忽略size 和 family 不然属性无效<h1 id="字体属性总结"><a href="#字体属性总结" class="headerlink" title="字体属性总结"></a>字体属性总结</h1><img src="https://s2.loli.net/2022/04/01/53tlzhIgfQVmF4i.png" alt="字体属性总结"><h2 id="color-定义文本颜色-分三种格式-开发中常用十六进制"><a href="#color-定义文本颜色-分三种格式-开发中常用十六进制" class="headerlink" title="color 定义文本颜色 分三种格式 开发中常用十六进制"></a>color 定义文本颜色 分三种格式 开发中常用十六进制</h2></li><li>预定义颜色值 red blue green之类的 </li><li>十六进制 #XXXXXX</li><li>rgb代码 rgb(xxx,xxx,xxx)或rgb(xxx%,xxx%,xxx%)<h1 id="text-align-设置文字水平对其的方式"><a href="#text-align-设置文字水平对其的方式" class="headerlink" title="text-align 设置文字水平对其的方式"></a>text-align 设置文字水平对其的方式</h1></li><li>属性值 left 左对其 （默认）</li><li>属性值 center 居中对齐</li><li>属性值 right 右对其<h1 id="text-decoration-装饰文本-（比如说-删除线条-下划线-上划线）"><a href="#text-decoration-装饰文本-（比如说-删除线条-下划线-上划线）" class="headerlink" title="text-decoration 装饰文本 （比如说 删除线条 下划线 上划线）"></a>text-decoration 装饰文本 （比如说 删除线条 下划线 上划线）</h1></li><li>属性值 none 默认 没有线条修饰 （一般用于消除链接文本的下划线）</li><li>属性值 underline 下划线 （a链接标签自带下划线）</li><li>overline 上划线 </li><li>line-through 删除线<h1 id="text-indent-文本缩进"><a href="#text-indent-文本缩进" class="headerlink" title="text-indent 文本缩进"></a>text-indent 文本缩进</h1></li><li>缩进的单位可是px像素 也可以是em当前元素的字体的大小<h1 id="text-height-行间距也就是行高"><a href="#text-height-行间距也就是行高" class="headerlink" title="text-height 行间距也就是行高"></a>text-height 行间距也就是行高</h1></li><li>行间距的算法是 上间距+文字大小+下间距<h1 id="文本属性总结"><a href="#文本属性总结" class="headerlink" title="文本属性总结"></a>文本属性总结</h1> <img src="https://s2.loli.net/2022/04/01/RXbmLJG9ByPdYo5.png" alt="文本属性总结"><h1 id="CSS的引入方式-分为3种"><a href="#CSS的引入方式-分为3种" class="headerlink" title="CSS的引入方式 (分为3种)"></a>CSS的引入方式 (分为3种)</h1><h2 id="内部样式（也叫内部样式表）"><a href="#内部样式（也叫内部样式表）" class="headerlink" title="内部样式（也叫内部样式表）"></a>内部样式（也叫内部样式表）</h2></li><li>就是把css写在html文件内</li><li>理论上style(样式标签)可以写在html的任何位置 但一般规范是写在head内title下</li><li>优点 方便控制整个页面的元素样式设置 代码 结构清晰</li><li>缺点 没有完全实现结构和样式的分离(还不是写在html里，只不过规定了个地方拉)<h2 id="行内样式（也就行内样式表）"><a href="#行内样式（也就行内样式表）" class="headerlink" title="行内样式（也就行内样式表）"></a>行内样式（也就行内样式表）</h2></li><li>就是把css写在标签内 直接style(样式标签): “font size: 30px; color: red;” 这种的 记得英文双引号</li><li>优点 快速改变单个标签</li><li>缺点 要是写很多样式就非常繁琐<h2 id="外部样式-单独创建css文件写样式-html里引用-css文件里不需要写style标签"><a href="#外部样式-单独创建css文件写样式-html里引用-css文件里不需要写style标签" class="headerlink" title="外部样式 (单独创建css文件写样式 html里引用)css文件里不需要写style标签"></a>外部样式 (单独创建css文件写样式 html里引用)<del>css文件里不需要写style标签</del></h2></li><li>html里使用link 标签引用 (link是个单标签)</li><li>属性 rel 定义当前文件于被引用文件的关系 引用css文件时 值指定为stylesheet 表示被引用的</li><li>属性 href 值为被引用文件的绝对路径或相对路径<h1 id="CSS引入方式总结"><a href="#CSS引入方式总结" class="headerlink" title="CSS引入方式总结"></a>CSS引入方式总结</h1><img src="https://s2.loli.net/2022/04/01/hZ1QXINCqLSdWBM.png" alt="Css引入方式总结"><h1 id="选择器是由基础选择器和复合选择器两大类"><a href="#选择器是由基础选择器和复合选择器两大类" class="headerlink" title="选择器是由基础选择器和复合选择器两大类"></a>选择器是由基础选择器和复合选择器两大类</h1><h3 id="问：那么复合选择器是什么呢？-答：复合选择器其实就是2个或多个基础选择器通过不同方式组合而成"><a href="#问：那么复合选择器是什么呢？-答：复合选择器其实就是2个或多个基础选择器通过不同方式组合而成" class="headerlink" title="问：那么复合选择器是什么呢？ 答：复合选择器其实就是2个或多个基础选择器通过不同方式组合而成"></a>问：那么复合选择器是什么呢？<br> 答：复合选择器其实就是2个或多个基础选择器通过不同方式组合而成</h3><h3 id="常用的复合选择器是后代选择器-子选择器-并集选择器-伪类选择器等等"><a href="#常用的复合选择器是后代选择器-子选择器-并集选择器-伪类选择器等等" class="headerlink" title="常用的复合选择器是后代选择器 子选择器 并集选择器 伪类选择器等等"></a>常用的复合选择器是后代选择器 子选择器 并集选择器 伪类选择器等等</h3><h2 id="后代选择器-重要-也可以看作套娃选择器"><a href="#后代选择器-重要-也可以看作套娃选择器" class="headerlink" title="后代选择器 (重要) 也可以看作套娃选择器"></a>后代选择器 (重要) <del>也可以看作套娃选择器</del></h2></li><li>语法 选择器1 选择器2 选择器3 { 样式代码 } </li><li>解析 选择器1包裹着选择器2 选择器2包裹着选择器3 <br>样式代码只修改被选择器1包裹的选择器2里的选择器3的样式<br>这里可以把选择器理解为元素</li><li>坑点 注意元素之间得空格 1 2 3 元素可以是任何基础选择器 比如说可以 .类名(代表调用这个类的标签) 标签(被包含的标签) { 样式代码 }<h2 id="子代选择器-（亲儿子选择器）只选择最亲的儿子元素"><a href="#子代选择器-（亲儿子选择器）只选择最亲的儿子元素" class="headerlink" title="子代选择器 （亲儿子选择器）只选择最亲的儿子元素"></a>子代选择器 （亲儿子选择器）只选择最亲的儿子元素</h2></li><li>语法 爹选择器 &gt; 儿子选择器 <br>这里可以把选择器理解为元素 其实也就是父级关系</li><li>解析 只选择爹选择器最近指定的儿子选择器<h2 id="并集选择器-用于集体声明-一次将多个不同的标签设置相同的元素"><a href="#并集选择器-用于集体声明-一次将多个不同的标签设置相同的元素" class="headerlink" title="并集选择器 用于集体声明 一次将多个不同的标签设置相同的元素"></a>并集选择器 用于集体声明 一次将多个不同的标签设置相同的元素</h2></li><li>语法 选择器1, 换行 选择器2, 换行 选择器3 { 样式代码 } <br>这里可以把选择器理解为元素</li><li>解析 选择器1 2 3 全部都被应用了样式 在最后之前的选择器名后都得加,然后回车 {其实回车是规范要求你不也行}<h2 id="伪类选择器-一般给某些选择器添加特殊效果-且用-表明"><a href="#伪类选择器-一般给某些选择器添加特殊效果-且用-表明" class="headerlink" title="伪类选择器 一般给某些选择器添加特殊效果 且用:表明"></a>伪类选择器 一般给某些选择器添加特殊效果 且用:表明</h2><h3 id="链接伪类"><a href="#链接伪类" class="headerlink" title="链接伪类"></a>链接伪类</h3></li><li>a:link 选择所有未被访问的链接</li><li>a:visited 选择所有已被访问的链接</li><li>a:hover 选择目前鼠标位置上的链接</li><li>a:active 选择活动链接(比如说鼠标点击并未松开)</li><li>链接伪类具有顺序性 如果顺序不对会无效果<h3 id="焦点伪类-focus-更改获取焦点的表单样式-一般配合input使用-也就是表单元素"><a href="#焦点伪类-focus-更改获取焦点的表单样式-一般配合input使用-也就是表单元素" class="headerlink" title="焦点伪类 focus 更改获取焦点的表单样式 一般配合input使用(也就是表单元素)"></a>焦点伪类 focus 更改获取焦点的表单样式 一般配合input使用(也就是表单元素)</h3></li><li>语法 input:focus</li></ul><h2 id="伪类元素选择器-附加内容"><a href="#伪类元素选择器-附加内容" class="headerlink" title="伪类元素选择器(附加内容)"></a>伪类元素选择器(附加内容)</h2><ul><li>first-letter 该选择器指定对象行内第一个字符的样式</li><li>first-line 该选择器指定对象第一行的样式</li><li>before 与内容相关的选择器搭配使用 在指定内容对象的行内前端插入内容</li><li>after 与内容相关的选择器搭配使用 在指定内容对象的行内后端插入内容<h1 id="选择器总结-1"><a href="#选择器总结-1" class="headerlink" title="选择器总结"></a>选择器总结</h1><img src="https://s2.loli.net/2022/04/02/MWexpXVK9yvjAnB.png" alt="选择器总结"><h1 id="CSS的元素显示模式分为两大类"><a href="#CSS的元素显示模式分为两大类" class="headerlink" title="CSS的元素显示模式分为两大类"></a>CSS的元素显示模式分为两大类</h1><h2 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h2></li></ul><ol><li>比较霸道 自己独占一行</li><li>高度 宽度 内外边距 都可以控制</li><li>宽度默认是父类容器的宽度</li><li>是一个容器及盒子，里面可以放块级元素和行内元素<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3></li></ol><ul><li>文字类元素内不能使用块级元素 比如说 P h这种的 绝对不行！ <del>虽然浏览器编译出可能不会有显示问题</del><h2 id="行内元素-一行可以放很多个"><a href="#行内元素-一行可以放很多个" class="headerlink" title="行内元素 一行可以放很多个"></a>行内元素 一行可以放很多个</h2><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3></li><li>链接里面不能再放链接 <del>链接:我去哪？</del></li><li>长 宽 不能直接设置</li><li>默认宽度就是内容本身的宽度</li><li>行内元素不能放块元素 但特殊情况下a可以放块级元素 不过需要转换才安全<h2 id="行内块元素-拥有着行内-和-块-元素的部分特征-人妖"><a href="#行内块元素-拥有着行内-和-块-元素的部分特征-人妖" class="headerlink" title="行内块元素 拥有着行内 和 块 元素的部分特征 人妖"></a>行内块元素 拥有着行内 和 块 元素的部分特征 <del>人妖</del></h2></li><li>这种元素常见的是img td input</li><li>它们的高度 宽度 内外边距可以直接设置（块元素特性）</li><li>它们的宽度就是内容本身的宽度 （行内元素特性）</li><li>一行可以有多个行内块元素 （行内元素特性）</li><li>和相邻的行内元素 行内块元素 会出现空白缝隙（自身特性）<h1 id="元素显示模式总结"><a href="#元素显示模式总结" class="headerlink" title="元素显示模式总结"></a>元素显示模式总结</h1><img src="https://s2.loli.net/2022/04/02/jwMt9ilL8ucaNzg.png" alt="元素显示模式总结"><h1 id="元素显示模式的转换-人们常说-想要成为别人必要舍弃自己"><a href="#元素显示模式的转换-人们常说-想要成为别人必要舍弃自己" class="headerlink" title="元素显示模式的转换 人们常说 想要成为别人必要舍弃自己"></a>元素显示模式的转换 人们常说 想要成为别人必要舍弃自己</h1></li><li>转换为行内元素 display:block; 获得行内元素的特性但舍弃了自己本有的</li><li>转换为块元素 display:inline; 获得块元素的特性但舍弃了自己本有的</li><li>转换为行内块元素 display:inline-block; 获得全部的力量但有所瑕疵<h1 id="CSS如何让块元素内的单行文本居中？"><a href="#CSS如何让块元素内的单行文本居中？" class="headerlink" title="CSS如何让块元素内的单行文本居中？"></a>CSS如何让块元素内的单行文本居中？</h1></li><li>首先直接改属性是没有的 不要想着 align: center了！</li><li>那么我们应该换思路 一个块元素本质上也就是一个块 </li><li>那么它就有最大高度 height(容器的高度)</li><li>那么我们可以修改link-height(一行的高度)与height(容器高度一样)那么文字就会居中了</li><li>为什么呢？ 因为行高的组成其实也就是 上下间距+文本高度</li><li>如果行高为40 字体大小为20 那么上下间距分别为10</li><li>此时如果容器的高度也是40 那么是不是字就被上下等高的间距挤在了中间了呢？  NB!!!!<h1 id="CSS的背景"><a href="#CSS的背景" class="headerlink" title="CSS的背景"></a>CSS的背景</h1><h2 id="background-color-背景颜色"><a href="#background-color-背景颜色" class="headerlink" title="background-color 背景颜色"></a>background-color 背景颜色</h2></li><li>如果不填颜色值 默认为透明 transparent(透明的)</li><li>容器默认是透明 不需要手动写 <del>这就是点空的地方弹广告的原理吗？</del><h2 id="background-image-背景图片-常用于小log和超大背景图"><a href="#background-image-背景图片-常用于小log和超大背景图" class="headerlink" title="background-image 背景图片 常用于小log和超大背景图"></a>background-image 背景图片 常用于小log和超大背景图</h2></li><li>参数 none 默认无背景图</li><li>参数 url 使用绝对或相对路径添加图片 ps:url() 一定要记得带上括号一起玩！<h2 id="background-repeat-背景图片平铺方式"><a href="#background-repeat-背景图片平铺方式" class="headerlink" title="background-repeat 背景图片平铺方式"></a>background-repeat 背景图片平铺方式</h2></li><li>参数 repeat 平铺</li><li>参数 no-repeat 不平铺</li><li>参数 repeat-x 沿着x轴平铺</li><li>参数 repeat-y 沿着y轴平铺</li><li>注意点 页面元素可以同时拥有背景颜色和背景图片 不过背景颜色处于最底层 图片相较于在上层<h2 id="background-position-背景图片位置"><a href="#background-position-背景图片位置" class="headerlink" title="background-position 背景图片位置"></a>background-position 背景图片位置</h2></li><li>参数 x y 可以是具体的数字或百分比 也可以是方位名词<h3 id="方位名词参数"><a href="#方位名词参数" class="headerlink" title="方位名词参数"></a>方位名词参数</h3></li><li>方位名词有 top left right center bottom</li><li>使用方位名词时 x与y的顺序无所谓</li><li>如果使用方位名词时只输入一个 那么另一个默认为center<h3 id="精确单位参数"><a href="#精确单位参数" class="headerlink" title="精确单位参数"></a>精确单位参数</h3></li><li>第一个必是X轴的值 第二个必是Y轴的值</li><li>如果只填写了一个精确单位的参数 Y轴默认居中(center)<h3 id="混合单位-也就是既填入了精确单位也填入了方位名词"><a href="#混合单位-也就是既填入了精确单位也填入了方位名词" class="headerlink" title="混合单位 也就是既填入了精确单位也填入了方位名词"></a>混合单位 也就是既填入了精确单位也填入了方位名词</h3></li><li>注意点就一个 第一个为X 第二个为Y<h1 id="background-attachment-背景图片是否固定"><a href="#background-attachment-背景图片是否固定" class="headerlink" title="background-attachment 背景图片是否固定"></a>background-attachment 背景图片是否固定</h1></li><li>参数 scroll 背景图片随着对象内容而滚动 （默认）</li><li>参数fixed 背景图片固定<h1 id="background-背景复合写法"><a href="#background-背景复合写法" class="headerlink" title="background 背景复合写法"></a>background 背景复合写法</h1></li><li>与字体复合写法相比 背景的复合写法是没有严格的顺序要求的</li><li>规范的写法为 背景颜色 背景图片地址 背景平铺方式 背景滚动方式 背景图片位置;<h1 id="背景颜色透明度"><a href="#背景颜色透明度" class="headerlink" title="背景颜色透明度"></a>背景颜色透明度</h1></li><li>语法 background: rgba(X,X,X,透明度)</li><li>解析 rgb本是颜色代码 多加了个A(alpha)透明度 取值为0-1<h1 id="背景总结↓"><a href="#背景总结↓" class="headerlink" title="背景总结↓"></a>背景总结↓</h1><img src="https://s2.loli.net/2022/04/03/YfgOGrnPVplwdbc.png" alt="背景总结"><h1 id="CSS的三大特性"><a href="#CSS的三大特性" class="headerlink" title="CSS的三大特性"></a>CSS的三大特性</h1><h2 id="叠层性"><a href="#叠层性" class="headerlink" title="叠层性"></a>叠层性</h2></li><li>也可以理解为样式覆盖 不过覆盖的只是相同的样式</li><li>比如说2个对同一个标签进行样式修改的标签选择器 第一个是 绿色 字大18 第二个是红色</li><li>那么第一个的绿色会被红色覆盖 但字大不会<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2></li><li>包容着你的爸标签的样式会应用到儿标签中</li><li>但一般只会继承text font     line 这些元素开头的 以及color属性<h3 id="行高的继承"><a href="#行高的继承" class="headerlink" title="行高的继承"></a>行高的继承</h3></li><li>有一种行高的写法是不直接给予确切的值 而是倍数 比如说 1.5</li><li>这时候行高是根据当前字体尺寸来乘以给予的倍数算的</li><li>而继承时 假如儿子有自己设置的字体尺寸 那行高也就是儿子的字体尺寸乘以1.5<h2 id="优先性"><a href="#优先性" class="headerlink" title="优先性"></a>优先性</h2><h3 id="每个选择器的权限等级不一-也可以说是权重-当一个标签被多个选择器指定样式-根据权限等级来应用样式"><a href="#每个选择器的权限等级不一-也可以说是权重-当一个标签被多个选择器指定样式-根据权限等级来应用样式" class="headerlink" title="每个选择器的权限等级不一(也可以说是权重) 当一个标签被多个选择器指定样式 根据权限等级来应用样式"></a>每个选择器的权限等级不一(也可以说是权重) 当一个标签被多个选择器指定样式 根据权限等级来应用样式</h3></li></ul><table><thead><tr><th align="center">选择器</th><th align="center">权限级别</th></tr></thead><tbody><tr><td align="center">继承 *选择器</td><td align="center">0,0,0,0</td></tr><tr><td align="center">元素选择器</td><td align="center">0,0,0,1</td></tr><tr><td align="center">类、伪类选择器</td><td align="center">0,0,1,0</td></tr><tr><td align="center">ID选择器</td><td align="center">0,1,0,0</td></tr><tr><td align="center">行内样式 style&#x3D;””</td><td align="center">1,0,0,0</td></tr><tr><td align="center">!important</td><td align="center">无限∞</td></tr></tbody></table><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>大家都是!important时 看自身本有的权限</li><li>浏览器默认是创建了一个a标签选择器 蓝色 有下划线 所以不会被继承的样式覆盖</li><li>复合选择器的权重会叠加 比如说.类选择器 标签选择器 组合一起的后代选择器 权重算为0,0,1,1</li><li>权重会叠加但永远不会进位 100个元素选择器组合成的复合选择器权重为0,0,0,100<h1 id="盒子模型-整个网页不过一个又一个的盒子组成而成"><a href="#盒子模型-整个网页不过一个又一个的盒子组成而成" class="headerlink" title="盒子模型 整个网页不过一个又一个的盒子组成而成"></a>盒子模型 整个网页不过一个又一个的盒子组成而成</h1><h2 id="盒子模型的组成"><a href="#盒子模型的组成" class="headerlink" title="盒子模型的组成"></a>盒子模型的组成</h2></li><li>外边框 margin</li><li>边框 border</li><li>内边距 padding</li><li>实际内容 content<br><img src="https://s2.loli.net/2022/04/05/3nVfw12L5YjNGQl.png" alt="盒子模型组成"><h3 id="边框-border"><a href="#边框-border" class="headerlink" title="边框 border"></a>边框 border</h3></li></ul><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">border-width</td><td align="center">定义边框的粗细，单位是px</td></tr><tr><td align="center">border-style</td><td align="center">定义边框的样式</td></tr><tr><td align="center">border-color</td><td align="center">定义边框的颜色</td></tr></tbody></table><h4 id="border-style"><a href="#border-style" class="headerlink" title="border-style"></a>border-style</h4><table><thead><tr><th align="center">属性值</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">solid</td><td align="center">实线边框</td></tr><tr><td align="center">dashed</td><td align="center">虚线边框</td></tr><tr><td align="center">dotted</td><td align="center">点线边框</td></tr></tbody></table><h4 id="边框的复合写法"><a href="#边框的复合写法" class="headerlink" title="边框的复合写法"></a>边框的复合写法</h4><ul><li>没有顺序要求 不过规范的写法为 先粗细 后样式 然后颜色<h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h4></li><li>盒子是有四条边 那么我们每边都可以自定义</li><li>border-top 顶部</li><li>border-right 右边</li><li>border-left 左边</li><li>border-bottom 底部</li><li>边框会影响盒子模型的实际大小 假如盒子设置宽&#x2F;高200 你设置的左右&#x2F;上下边框为10 那么实际大小为220 如果想要保持原有大小得把宽的值减去左右边框的值达到平衡<h4 id="边框的细线边框"><a href="#边框的细线边框" class="headerlink" title="边框的细线边框"></a>边框的细线边框</h4></li></ul><table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">border-collapse</td><td align="center">collapse</td><td align="center">设置单元格相邻边框合并在一起</td></tr><tr><td align="center">默认情况下</td><td align="center">是不合并的</td><td align="center">显的边框很粗</td></tr></tbody></table><h3 id="padding-内边框-指的是实际内容和外边框之间的距离"><a href="#padding-内边框-指的是实际内容和外边框之间的距离" class="headerlink" title="padding 内边框 指的是实际内容和外边框之间的距离"></a>padding 内边框 指的是实际内容和外边框之间的距离</h3><ul><li>padding-top 内边框顶部</li><li>padding-right 内边框右边</li><li>padding-left 内边框左边</li><li>padding-bottom 内边框底部</li><li>内边框会影响盒子模型的实际大小 解决方法也是把盒子模型本身的宽&#x2F;高度减去左右&#x2F;上下内边框</li><li>但如果你没有指明盒子的width&#x2F;height padding是不会撑开盒子的<h3 id="padding-内边距的复合语法规则"><a href="#padding-内边距的复合语法规则" class="headerlink" title="padding 内边距的复合语法规则"></a>padding 内边距的复合语法规则</h3></li></ul><table><thead><tr><th align="center">值的个数</th><th align="center">表达含义</th></tr></thead><tbody><tr><td align="center">padding: 5px;</td><td align="center">一个值 上下左右的边距皆为5px</td></tr><tr><td align="center">padding: 5px 10px;</td><td align="center">两个值 上下边距为5px 左右边距为10px</td></tr><tr><td align="center">padding: 5px 10px 20px;</td><td align="center">三个值 上边距为5px 左右边距为10px 下边距为20px</td></tr><tr><td align="center">padding: 5px 10px 15px 20px;</td><td align="center">四个值 上边距为5px 右边距为10px 下边距15px 左边距为20px 顺时针转</td></tr></tbody></table><h3 id="margin-外边距"><a href="#margin-外边距" class="headerlink" title="margin 外边距"></a>margin 外边距</h3><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">margin-top</td><td align="center">顶部外边距</td></tr><tr><td align="center">margin-right</td><td align="center">右部外边距</td></tr><tr><td align="center">margin-bottom</td><td align="center">底部外边距</td></tr><tr><td align="center">margin-left</td><td align="center">左部外边距</td></tr></tbody></table><h3 id="margin复合写法和padding一样"><a href="#margin复合写法和padding一样" class="headerlink" title="margin复合写法和padding一样"></a>margin复合写法和padding一样</h3><h2 id="外边距让块级盒子水平居中"><a href="#外边距让块级盒子水平居中" class="headerlink" title="外边距让块级盒子水平居中"></a>外边距让块级盒子水平居中</h2><ul><li>条件1 必须设置宽度(width)</li><li>条件2 左右外边距设置为auto</li></ul><h3 id="如果想让盒子内的文字垂直居中-让line-height-x3D-盒子的height就可以"><a href="#如果想让盒子内的文字垂直居中-让line-height-x3D-盒子的height就可以" class="headerlink" title="如果想让盒子内的文字垂直居中 让line-height&#x3D;盒子的height就可以"></a>如果想让盒子内的文字垂直居中 让line-height&#x3D;盒子的height就可以</h3><h3 id="如果想让盒子里的行内-x2F-行内块元素水平居中的话，请把文字的父亲加上text-align-center"><a href="#如果想让盒子里的行内-x2F-行内块元素水平居中的话，请把文字的父亲加上text-align-center" class="headerlink" title="如果想让盒子里的行内&#x2F;行内块元素水平居中的话，请把文字的父亲加上text-align: center;"></a>如果想让盒子里的行内&#x2F;行内块元素水平居中的话，请把文字的父亲加上text-align: center;</h3><h2 id="有一种特殊情况是-相邻块元素垂直外边框合并问题"><a href="#有一种特殊情况是-相邻块元素垂直外边框合并问题" class="headerlink" title="有一种特殊情况是 相邻块元素垂直外边框合并问题"></a>有一种特殊情况是 相邻块元素垂直外边框合并问题</h2><ul><li>触发条件 上下相邻 上面的盒子有margin-bottom 值 下面盒子有margin-top 值</li><li>问题呈现形式 值小的会被外边距消除</li><li>解决方法 尽量给一个盒子添加margin值<br><img src="https://s2.loli.net/2022/04/05/d5PRCnM13DeK9tv.png" alt="相邻块元素垂直外边距的合并"></li></ul><h2 id="还有一种特殊情况是-嵌套块元素垂直外边框塌陷问题"><a href="#还有一种特殊情况是-嵌套块元素垂直外边框塌陷问题" class="headerlink" title="还有一种特殊情况是 嵌套块元素垂直外边框塌陷问题"></a>还有一种特殊情况是 嵌套块元素垂直外边框塌陷问题</h2><ul><li>触发条件 2个嵌套关系的块元素 父元素和子元素同时都有上外边距</li><li>问题呈现形式 想象中父元素margin-top 20px 子元素margin-top 10px 就像合并之前一样<br>但实际上margin-top只会执行父元素的，但是值是从父子中选最大的<br><img src="https://s2.loli.net/2022/04/05/6xVJ5ePDMcHwQF8.png" alt="嵌套块元素垂直外边框的塌陷"><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3></li></ul><ol><li>给父元素添加border （恩断义绝）</li><li>给父元素添加padding （恩断义绝）</li><li>用属性 overflow: hidden</li></ol><h3 id="消除内外边距"><a href="#消除内外边距" class="headerlink" title="消除内外边距"></a>消除内外边距</h3><ul><li>问 为什么需要消除？</li><li>答 很多浏览器的默认设置不一样 我们消除手动设置才好</li><li>用通配符选择器 padding: 0 margin: 0<h3 id="附加点"><a href="#附加点" class="headerlink" title="附加点"></a>附加点</h3></li><li>行内元素一般只设置左右内外边距 因为她们不能设置宽高上下的设置没有用 <del>除非你转换为块级或行内块</del></li></ul><h2 id="圆角边框-border-radius"><a href="#圆角边框-border-radius" class="headerlink" title="圆角边框 border-radius"></a>圆角边框 border-radius</h2><table><thead><tr><th align="center">属性</th><th align="center">值</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">border-radius</td><td align="center">数值或百分比</td><td align="center">让边框圆角化</td></tr></tbody></table><h3 id="用border-radius做圆形"><a href="#用border-radius做圆形" class="headerlink" title="用border-radius做圆形"></a>用border-radius做圆形</h3><ul><li>首先容器得是个正方形</li><li>然后把border-radius的值设置为百分之50或设置为长&#x2F;宽的一半</li></ul><h3 id="用border-radius做圆角矩形"><a href="#用border-radius做圆角矩形" class="headerlink" title="用border-radius做圆角矩形"></a>用border-radius做圆角矩形</h3><ul><li>首先容器得是个长方体</li><li>然后把border-radius的值设置为高度的一半</li></ul><h3 id="圆角边框也可以单独设置一个角"><a href="#圆角边框也可以单独设置一个角" class="headerlink" title="圆角边框也可以单独设置一个角"></a>圆角边框也可以单独设置一个角</h3><ul><li>border-top-left-radius 左上角</li><li>border-top-right-radius 右上角</li><li>border-bottom-right-radius 右下角</li><li>border-bottom-left-radius 左下角</li></ul><h3 id="border-radius也可以一次给予多个值"><a href="#border-radius也可以一次给予多个值" class="headerlink" title="border-radius也可以一次给予多个值"></a>border-radius也可以一次给予多个值</h3><table><thead><tr><th align="center">值的数量</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">一个</td><td align="center">4个角都覆盖圆角</td></tr><tr><td align="center">两个</td><td align="center">第一个值对于的是左上和右下，第二个值对于右上和左下</td></tr><tr><td align="center">三个</td><td align="center">第一个值对于的是左上 第二个值对于右上和左下 第三个值对应右下</td></tr><tr><td align="center">四个</td><td align="center">第一个值对于左上 第二个值对于右上 第三个值对于右下 第四个值对于左下</td></tr></tbody></table><h2 id="盒子阴影-box-shadow"><a href="#盒子阴影-box-shadow" class="headerlink" title="盒子阴影 box-shadow"></a>盒子阴影 box-shadow</h2><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">h-shadow(必须)</td><td align="center">水平阴影的位置</td></tr><tr><td align="center">v-shadow(必须)</td><td align="center">垂直阴影的位置</td></tr><tr><td align="center">blue(可选)</td><td align="center">模糊距离</td></tr><tr><td align="center">spred(可选)</td><td align="center">阴影尺寸</td></tr><tr><td align="center">color(可选)</td><td align="center">阴影颜色</td></tr><tr><td align="center">inset(可选)</td><td align="center">将默认的外阴影设置为内阴影</td></tr></tbody></table><h2 id="文字阴影-text-shadow（和盒子阴影相比也就少了可选2属性）"><a href="#文字阴影-text-shadow（和盒子阴影相比也就少了可选2属性）" class="headerlink" title="文字阴影 text-shadow（和盒子阴影相比也就少了可选2属性）"></a>文字阴影 text-shadow（和盒子阴影相比也就少了可选2属性）</h2><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">h-shadow(必须)</td><td align="center">水平阴影的位置</td></tr><tr><td align="center">v-shadow(必须)</td><td align="center">垂直阴影的位置</td></tr><tr><td align="center">blue(可选)</td><td align="center">模糊距离</td></tr><tr><td align="center">color(可选)</td><td align="center">阴影颜色</td></tr></tbody></table><h1 id="tip-网页设计第一准则：多个块横找浮动！-多个块纵找标准！（3大设计流-标准-浮动-定位）"><a href="#tip-网页设计第一准则：多个块横找浮动！-多个块纵找标准！（3大设计流-标准-浮动-定位）" class="headerlink" title="tip:网页设计第一准则：多个块横找浮动！ 多个块纵找标准！（3大设计流 标准 浮动 定位）"></a>tip:网页设计第一准则：多个块横找浮动！ 多个块纵找标准！（3大设计流 标准 浮动 定位）</h1><h1 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动 float"></a>浮动 float</h1><h2 id="关于浮动的问题"><a href="#关于浮动的问题" class="headerlink" title="关于浮动的问题"></a>关于浮动的问题</h2><ul><li>问：为什么需要浮动？</li><li>答：有时候标准流很难做到一些事情浮动都可以做到</li><li>问: 比如说什么事情很难做到？</li><li>答: 把块级元素横强行转换排列时会有无法控制的间隔 而用浮动可以解决</li><li>问：什么是浮动？</li><li>答：float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘或另一个浮动框的边缘</li></ul><h2 id="浮动的特性"><a href="#浮动的特性" class="headerlink" title="浮动的特性"></a>浮动的特性</h2><ol><li>浮动元素会脱离标准流(俗称脱标)</li></ol><ul><li>脱离标准普通流控制(浮)移动到指定位置(动)</li><li>浮动的盒子不再保留原先位置</li></ul><ol start="2"><li>浮动的元素会一行内显示并且元素顶部对齐</li><li>浮动的元素具有部分行内块元素的特性</li></ol><ul><li>比如说块级元素宽度本默认和父级一样，但添加浮动后宽度根据内容而定</li><li>浮动的盒子是没有间隙的，紧挨着一起</li><li>行内元素同理</li></ul><h1 id="网页设计准则"><a href="#网页设计准则" class="headerlink" title="网页设计准则"></a>网页设计准则</h1><ol><li>标准流里套浮动</li><li>先量盒子后摆放</li></ol><h1 id="浮动会出现的问题"><a href="#浮动会出现的问题" class="headerlink" title="浮动会出现的问题"></a>浮动会出现的问题</h1><h3 id="有时候我们的标准流盒子的高度不太好设定死，我们的理想状态是里面有多少盒子浮动就会自己撑开标准流父盒子的高度，但这实际上会出现一个问题，被设为浮动的盒子，父盒子其实是感受不到它们的存在的，因为浮动的盒子不占位置，浮动的盒子会被挤在下一行这时候已经显示异常了如果父盒子下面还有其他标准流，就会在靠在父盒子的后面。"><a href="#有时候我们的标准流盒子的高度不太好设定死，我们的理想状态是里面有多少盒子浮动就会自己撑开标准流父盒子的高度，但这实际上会出现一个问题，被设为浮动的盒子，父盒子其实是感受不到它们的存在的，因为浮动的盒子不占位置，浮动的盒子会被挤在下一行这时候已经显示异常了如果父盒子下面还有其他标准流，就会在靠在父盒子的后面。" class="headerlink" title="有时候我们的标准流盒子的高度不太好设定死，我们的理想状态是里面有多少盒子浮动就会自己撑开标准流父盒子的高度，但这实际上会出现一个问题，被设为浮动的盒子，父盒子其实是感受不到它们的存在的，因为浮动的盒子不占位置，浮动的盒子会被挤在下一行这时候已经显示异常了如果父盒子下面还有其他标准流，就会在靠在父盒子的后面。"></a>有时候我们的标准流盒子的高度不太好设定死，我们的理想状态是里面有多少盒子浮动就会自己撑开标准流父盒子的高度，但这实际上会出现一个问题，被设为浮动的盒子，父盒子其实是感受不到它们的存在的，因为浮动的盒子不占位置，浮动的盒子会被挤在下一行<br><del>这时候已经显示异常了</del><br>如果父盒子下面还有其他标准流，就会在靠在父盒子的后面。</h3><h4 id="所以我们需要清除浮动，让标准流里的盒子重新占位，而不是在天上乱飞清除浮动只是清除浮动带来的影响"><a href="#所以我们需要清除浮动，让标准流里的盒子重新占位，而不是在天上乱飞清除浮动只是清除浮动带来的影响" class="headerlink" title="所以我们需要清除浮动，让标准流里的盒子重新占位，而不是在天上乱飞清除浮动只是清除浮动带来的影响"></a>所以我们需要清除浮动，让标准流里的盒子重新占位，而不是在天上乱飞<br><del>清除浮动只是清除浮动带来的影响</del></h4><h3 id="清除浮动的4种方法"><a href="#清除浮动的4种方法" class="headerlink" title="清除浮动的4种方法"></a>清除浮动的4种方法</h3><ol><li>额外标签法 也叫隔墙法(W3C推荐)</li></ol><ul><li>在最后浮动的元素后面添加一个空的标签，然后赋予clear: both <del>其实你也可以clear: left clear: right</del></li><li>优点 简单快捷，书写方便</li><li>缺点 添加许多无用标签 影响代码可读性</li><li>注意点 添加的空标签一定得是块级标签(br是个例外)</li></ul><ol start="2"><li>用overflow属性</li></ol><ul><li>把值设置为 hidden auto scroll</li><li>优点 快 短 狠</li><li>缺点 溢出的部分会被拦腰斩截 <del>还好浮动不会溢出</del></li><li>注意点 子不教父之过 给浮动元素们的爸爸加上</li></ul><ol start="3"><li>用伪元素after</li></ol><ul><li>代码 <br>.clearfix:after{<br>content: “”;<br>display: block;<br>height: 0;<br>clear: both;<br>visibility: hidden;}<br>.clearfix{<br>&#x2F;&#x2F;IE6-7兼容代码<br>*zoom: 1;<br>}</li><li>缺点: 不支持低版本IE<del>谁用IE啊？</del></li><li>注意点 子不教父之过 给浮动元素们的爸爸加上</li></ul><ol start="4"><li>用双伪元素</li></ol><ul><li>代码: <br>.clarfix:before,<br>clarfix:after{<br>content: “”;<br>display: table;<br>}<br>.clarfix:after{<br>clear: both;<br>}<br>.clearfix{<br>&#x2F;&#x2F;IE6-7兼容代码<br>*zoom: 1;<br>}</li><li>缺点: 不支持低版本IE<del>谁用IE啊？</del></li><li>注意点 子不教父之过 给浮动元素们的爸爸加上<h3 id="清除浮动的本质是？"><a href="#清除浮动的本质是？" class="headerlink" title="清除浮动的本质是？"></a>清除浮动的本质是？</h3><h4 id="清除浮动的本质其实就算清除浮动元素脱离标准流后带来的影响"><a href="#清除浮动的本质其实就算清除浮动元素脱离标准流后带来的影响" class="headerlink" title="清除浮动的本质其实就算清除浮动元素脱离标准流后带来的影响"></a>清除浮动的本质其实就算清除浮动元素脱离标准流后带来的影响</h4><h3 id="清除浮动采用的策略是什么？"><a href="#清除浮动采用的策略是什么？" class="headerlink" title="清除浮动采用的策略是什么？"></a>清除浮动采用的策略是什么？</h3><h4 id="采用闭合法-把浮动元素“关”在父盒子里使其无法影响到外边的盒子"><a href="#采用闭合法-把浮动元素“关”在父盒子里使其无法影响到外边的盒子" class="headerlink" title="采用闭合法 把浮动元素“关”在父盒子里使其无法影响到外边的盒子"></a>采用闭合法 把浮动元素“关”在父盒子里使其无法影响到外边的盒子</h4><h3 id="什么是额外标签法？"><a href="#什么是额外标签法？" class="headerlink" title="什么是额外标签法？"></a>什么是额外标签法？</h3><h4 id="采用闭合法-在最后一个浮动元素的后面添加一个空的块级元素-也可以是br这个例外-然后给她添加去除浮动的样式属性clear-both-或者-clear-left-或者-clear-right一般不推荐使用但可能会遇见有人这么写"><a href="#采用闭合法-在最后一个浮动元素的后面添加一个空的块级元素-也可以是br这个例外-然后给她添加去除浮动的样式属性clear-both-或者-clear-left-或者-clear-right一般不推荐使用但可能会遇见有人这么写" class="headerlink" title="采用闭合法 在最后一个浮动元素的后面添加一个空的块级元素(也可以是br这个例外)然后给她添加去除浮动的样式属性clear: both 或者 clear: left 或者 clear: right一般不推荐使用但可能会遇见有人这么写"></a>采用闭合法 在最后一个浮动元素的后面添加一个空的块级元素(也可以是br这个例外)然后给她添加去除浮动的样式属性clear: both 或者 clear: left 或者 clear: right<br>一般不推荐使用但可能会遇见有人这么写</h4><h3 id="什么时候清除浮动？"><a href="#什么时候清除浮动？" class="headerlink" title="什么时候清除浮动？"></a>什么时候清除浮动？</h3><h4 id="1-父盒子没有宽度2-子盒子浮动了3-盒子浮动影响下面的标准流布局"><a href="#1-父盒子没有宽度2-子盒子浮动了3-盒子浮动影响下面的标准流布局" class="headerlink" title="1.父盒子没有宽度2.子盒子浮动了3.盒子浮动影响下面的标准流布局"></a>1.父盒子没有宽度<br>2.子盒子浮动了<br>3.盒子浮动影响下面的标准流布局</h4></li></ul><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h3 id="也就是把盒子定在网页中的任意位置"><a href="#也就是把盒子定在网页中的任意位置" class="headerlink" title="也就是把盒子定在网页中的任意位置"></a>也就是把盒子定在网页中的任意位置</h3><h2 id="定位的组成"><a href="#定位的组成" class="headerlink" title="定位的组成"></a>定位的组成</h2><h3 id="也就是-定位模式-边偏移-x3D-定位"><a href="#也就是-定位模式-边偏移-x3D-定位" class="headerlink" title="也就是 定位模式 + 边偏移 &#x3D; 定位"></a>也就是 定位模式 + 边偏移 &#x3D; 定位</h3><h3 id="定位模式-position"><a href="#定位模式-position" class="headerlink" title="定位模式 position"></a>定位模式 position</h3><table><thead><tr><th align="center">值</th><th align="center">对应模式</th></tr></thead><tbody><tr><td align="center">static</td><td align="center">静态定位</td></tr><tr><td align="center">relative</td><td align="center">相对定位</td></tr><tr><td align="center">absolute</td><td align="center">绝对定位</td></tr><tr><td align="center">fixed</td><td align="center">固定定位</td></tr></tbody></table><h3 id="静态定位-lt-摊平型-gt"><a href="#静态定位-lt-摊平型-gt" class="headerlink" title="静态定位 &lt;摊平型&gt;"></a>静态定位 &lt;摊平型&gt;</h3><ul><li>默认就是，设置以后即为标准流 <del>也就是无定位开摆</del></li></ul><h3 id="相对定位-lt-自我型-gt"><a href="#相对定位-lt-自我型-gt" class="headerlink" title="相对定位 &lt;自我型&gt;"></a>相对定位 &lt;自我型&gt;</h3><ul><li>以自我为中心 偏移以自己原来的位置为坐标</li><li>是个赖皮，哪怕自己已经定位去别的地方了，但原来的位置依就保留，后面的盒子依然以标准流对待她</li></ul><h3 id="边偏移-定位限定"><a href="#边偏移-定位限定" class="headerlink" title="边偏移 定位限定"></a>边偏移 定位限定</h3><table><thead><tr><th align="center">边偏移属性</th><th align="center">实例</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">top</td><td align="center">top: 80px;</td><td align="center">顶部偏移量，定位元素相对其父元素上边线的距离。</td></tr><tr><td align="center">bottom</td><td align="center">bottom: 80px;</td><td align="center">底部偏移量，定位元素相对其父元素下边线的距离。</td></tr><tr><td align="center">left</td><td align="center">left: 80px;</td><td align="center">左侧偏移量，定位元素相对于其父元素左边线的距离。</td></tr><tr><td align="center">right</td><td align="center">right: 80px;</td><td align="center">右侧偏移值，定位元素相对于其父元素右边线的距离。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库函数依赖</title>
    <link href="/2022/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
    <url>/2022/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h1 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h1><h3 id="是指关系中各属性或属性组之间的相互依赖关系。它是关系规范化的理论基础。"><a href="#是指关系中各属性或属性组之间的相互依赖关系。它是关系规范化的理论基础。" class="headerlink" title="是指关系中各属性或属性组之间的相互依赖关系。它是关系规范化的理论基础。"></a>是指关系中各属性或属性组之间的相互依赖关系。它是关系规范化的理论基础。</h3><span id="more"></span><h1 id="函数依赖的定义"><a href="#函数依赖的定义" class="headerlink" title="函数依赖的定义"></a>函数依赖的定义</h1><h3 id="给定一个关系模型R，X和Y都是R的属性或属性组，对于X的每个确定值在何时何刻Y都只有一个唯一确定的值与之对应，则称”X函数决定Y”或称为”Y函数依赖于X“，X称为决定因素，记为X→Y"><a href="#给定一个关系模型R，X和Y都是R的属性或属性组，对于X的每个确定值在何时何刻Y都只有一个唯一确定的值与之对应，则称”X函数决定Y”或称为”Y函数依赖于X“，X称为决定因素，记为X→Y" class="headerlink" title="给定一个关系模型R，X和Y都是R的属性或属性组，对于X的每个确定值在何时何刻Y都只有一个唯一确定的值与之对应，则称”X函数决定Y”或称为”Y函数依赖于X“，X称为决定因素，记为X→Y"></a>给定一个关系模型R，X和Y都是R的属性或属性组，对于X的每个确定值在何时何刻Y都只有一个唯一确定的值与之对应，则称”X函数决定Y”或称为”Y函数依赖于X“，X称为决定因素，记为X→Y</h3><h1 id="函数依赖的种类"><a href="#函数依赖的种类" class="headerlink" title="函数依赖的种类"></a>函数依赖的种类</h1><ul><li>完全函数依赖：如果属性Y函数依赖于复合属性X，且不和X的任何子集函数相依赖，则称”Y完全依赖余函数X“</li><li>部分函数依赖：对于一个函数依赖：X→Y，如果存在Z∈X（Z属于X）,且有Z→Y成立，则称”Y部分函数依赖于X“</li><li>传递函数依赖：在关系模式中，如果X→Y（不能Y→X),Y→Z，若存在X→Z，则称”Z传递依赖于X“</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL Server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML5基础</title>
    <link href="/2022/03/26/HTML5%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/26/HTML5%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><del>不过是写给呆宝的笔记罢了</del><span id="more"></span></p><h1 id="关于HTML5字体的加粗-斜体-删除线-下划线-标签"><a href="#关于HTML5字体的加粗-斜体-删除线-下划线-标签" class="headerlink" title="关于HTML5字体的加粗 斜体 删除线 下划线 标签"></a>关于HTML5字体的加粗 斜体 删除线 下划线 标签</h1><ol><li>strong 和 b 一般推荐使用strong来加粗语义更强烈</li><li>em 和 i 一般推荐使用em来斜体语义更强烈</li><li>del 和 s 一般推荐del来添加删除线语义更强烈</li><li>ins 和 u 一般推荐使用ins来添加下划线语义更强</li></ol><h1 id="容器标签-本身没有语义"><a href="#容器标签-本身没有语义" class="headerlink" title="容器标签 本身没有语义"></a>容器标签 本身没有语义</h1><ul><li>div 占一整行 大盒子</li><li>span 一行可以有很多个 小盒子</li></ul><h1 id="图片标签-img-也就是image的缩写-PS-单标签"><a href="#图片标签-img-也就是image的缩写-PS-单标签" class="headerlink" title="图片标签 img 也就是image的缩写 PS:单标签"></a>图片标签 img 也就是image的缩写 PS:单标签</h1><ul><li>她有以下属性↓</li></ul><ol><li>src 是必须的属性 指定图像的 路径 文件名 得看 绝对路径 相对路径</li><li>alt 当图片显示失败时 显示的文字</li><li>title 当鼠标移动到图片时出现的文字</li><li>width 设置宽度</li><li>height 设置高度</li><li><del>border 设置边框粗细</del> HTML5已舍弃</li></ol><h2 id="相对路径-和-绝对路径-怕有人分不清特意说一下"><a href="#相对路径-和-绝对路径-怕有人分不清特意说一下" class="headerlink" title="相对路径 和 绝对路径 怕有人分不清特意说一下"></a>相对路径 和 绝对路径 <del>怕有人分不清特意说一下</del></h2><h3 id="相对路径-有三种情况-以被引用文件的所在位置为参考基础"><a href="#相对路径-有三种情况-以被引用文件的所在位置为参考基础" class="headerlink" title="相对路径 有三种情况 以被引用文件的所在位置为参考基础"></a>相对路径 有三种情况 以被引用文件的所在位置为参考基础</h3><ul><li>同级 和被引用文件在一起<br>比如说 引用文件在 D:\HTML5\引用文件.html 被引用文件在 D:\HTML5\被引用文件.jpg <br>她们都在一起所以为同级</li><li>下级 被引用文件处于引用文件的下层 <br>这时候就得用 &#x2F; 表示去往下一级<br>引用文件在 D:\HTML5\引用文件.html 被引用文件在 D:\HTML5\被引用文件夹\被引用文件.jpg <br>被引用文件在被引用文件夹里<br>被引用文件夹在HTML5文件夹下<br>所以被引用文件是在引用文件的下级<br>相对路径表示为 被引用文件夹&#x2F;被应用文件.jpg</li><li>上级 和下级相反 被引用文件处于引用文件上层 这时候就得用 ..&#x2F; 表示返回上一级</li></ul><h3 id="绝对路径-从盘符开始直达目标文件位置"><a href="#绝对路径-从盘符开始直达目标文件位置" class="headerlink" title="绝对路径 从盘符开始直达目标文件位置"></a>绝对路径 从盘符开始直达目标文件位置</h3><ul><li>用\去往下一级 <del>上面的比如说里就用的绝对路径表示</del></li><li>可以填入网络上的绝对地址 <del>比如说一个图片的链接</del></li></ul><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><ul><li>声明方式 a anchor的缩写 anchor名词：锚、靠山、台柱子 动词：抛锚、使稳固、主持节目</li><li>href 跳转目标 必须属性</li><li>target 窗口弹出方式 target 名词：目标、圆形小盾、靶子、对象 动词：选择目标、瞄准、把…作为目标、面向<br> 不填写默认_self 还可以用_blank<br>_self的话就会用当前页面打开目标网页老的自然被顶替为新的<br>_blank的话会新打开一个窗口打开目标网页</li></ul><h2 id="链接类别"><a href="#链接类别" class="headerlink" title="链接类别"></a>链接类别</h2><ul><li>外部链接 一般为<a href="http://www.baidu.com/">http://www.baidu.com</a> 这种 不属于网站内部拥有的</li><li>内部链接 为网站内部页面之间的相互链接 用相对路径 或绝对路径即可</li><li>空链接 简而言之就是点了没反应的链接 把href的值设置为#即可</li><li>下载链接 把href的值设置为你想给人下载文件的位置 </li><li>网页元素链接 点击网页中的元素即可跳转 <a href="http://www.baidu.com"><img src="https://sm.ms/image/bIsm6Q2hFEjgiVl" alt="点我进百度"> </a></li><li>锚点链接 可以理解为网页上的目录点 点击即可快速跳转到想看的部分<br>语法: href&#x3D;”#自定义名”  然后找到想要跳转到的标签 添加id属性值为自定义名</li></ul><h1 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h1><ul><li>!–我是被注释的文本–</li></ul><h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><ul><li>table 创建表格</li><li>tr 定义表格中的行 必须嵌套在table里    </li><li>td 定义表格中的单元格 必须嵌套在tr里</li><li>th 表头单元格将里面的内容加粗居中显示</li></ul><h1 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h1><ul><li>align 规定对齐方式</li><li>border 规定是否有边框<del>默认没有</del></li><li>cellpadding 规定单元与内容之间的空白，默认为1</li><li>cellspacing 规定单元格与单元格之间的空白 默认为2</li></ul><h1 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h1><ul><li>thead 表格头部标签里面必须含有hr</li><li>tbody 表格主体标签里面一般存放数据主体</li></ul><h1 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h1><h2 id="一般分为2种常见情况-跨行合并-跨列合并"><a href="#一般分为2种常见情况-跨行合并-跨列合并" class="headerlink" title="一般分为2种常见情况 跨行合并 跨列合并"></a>一般分为2种常见情况 跨行合并 跨列合并</h2><ul><li>跨列合并 将合并代码写在想合并的单元格中最左侧的单元格 语法:colspan&#x3D;“你合并的数量” 然后将被合并的单元格标签删除</li><li>跨行合并 将合并代码写在想合并的单元格中最上面的单元格 语法:rowspan&#x3D;“你合并的数量” 然后将被合并的单元格标签删除</li></ul><h1 id="列表标签-重要！"><a href="#列表标签-重要！" class="headerlink" title="列表标签(重要！)"></a>列表标签(重要！)</h1><ul><li>无序列表 ul创建无序列表 li添加列表项<br> ul里只能放li标签 其他都不行！<br>但li里面什么都可以放</li><li>有序列表 ol创建有序列表 li添加列表项<br> ul里只能放li标签 其他都不行！<br>但li里面什么都可以放</li><li>自定义列表 dl创建自定义列表 dt 定义项目 dd添加项目描述<br> dl里只能放dt和dd 其他都不行！<br> dt和dd的数量不限 但通常一个dt带很多dd<br>dt和dd里什么都可以放</li></ul><h1 id="表单的组成"><a href="#表单的组成" class="headerlink" title="表单的组成"></a>表单的组成</h1><h2 id="一个网站注册往往都是以表单的方式得到用户信息，但一个完整的表单是由-表单域-表单控件-提示信息-三部分组成"><a href="#一个网站注册往往都是以表单的方式得到用户信息，但一个完整的表单是由-表单域-表单控件-提示信息-三部分组成" class="headerlink" title="一个网站注册往往都是以表单的方式得到用户信息，但一个完整的表单是由 表单域 表单控件 提示信息 三部分组成"></a>一个网站注册往往都是以表单的方式得到用户信息，但一个完整的表单是由 表单域 表单控件 提示信息 三部分组成</h2><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><ul><li>标签 form</li><li>属性 action 属性值 url地址 用于指定接受并处理表单数据的服务器程序的url地址</li><li>属性 method 属性值 get&#x2F;post 用于设置表单的数据提交方式</li><li>属性 name 属性值 名称 用于命名表单域 方便区分<h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h3><h2 id="input-输入-为单标签"><a href="#input-输入-为单标签" class="headerlink" title="input  输入 为单标签"></a>input  输入 为单标签</h2></li></ul><ol><li>属性name 属性值 用户定义 定义input元素的名称 有radio和checkbox的input标签一般会同名 否则单选和多选会异常</li><li>属性value 属性值 用户定义 定义input元素的值 写给后端看的</li><li>属性checked 属性值 checked<del>这不是一样吗？</del> 针对于单选框和复选框 用于网站打开时默认选中</li><li>属性maxlength 属性值 正整数 限制表单输入的最大字符数</li></ol><br><h2 id="input包含一个必须输入属性-type-根据type接收的值-输入字段有很多形式"><a href="#input包含一个必须输入属性-type-根据type接收的值-输入字段有很多形式" class="headerlink" title="input包含一个必须输入属性 type 根据type接收的值 输入字段有很多形式"></a>input包含一个必须输入属性 type 根据type接收的值 输入字段有很多形式</h2><ol><li>text 当type的值为text时 即是一个普通的输入框</li><li>password 当type的值为password时 即是一个输入字符被特定隐藏符合替代的的输入框</li><li>radio 当type的值为radio时 即是一个圆形单选按钮</li><li>checkbox 当type的值为checkbox时 即是一个正方形的多选框 </li><li>submit 当type的值为submit时 即是一个提交按钮 作用是提交数据给已指定的服务器 按钮显示的名字默认就是提交 更改value的值也会更改按键显示的值</li><li>reset 当type的值为reset时 即是一个重置按钮 作用是重置表格域里所有input元素的值 按键显示的名字就是重置 更改value的值也会更改按键显示的值</li><li>button 当type的值为button是 即是一个普通按钮 作用一般绑定js使用 按键显示的名字默认什么都没有 更改value的值也会更改按键显示的值</li><li>file 当type的值为file时 即是一个选择文件按钮 作用就是选择文件上传</li></ol><h2 id="label-标签"><a href="#label-标签" class="headerlink" title="label 标签"></a>label 标签</h2><ol><li>用于绑定某个表单元素 点击label标签讲焦点跳到绑定的表单元素</li><li>语法：属性for绑定表单控件的id的值<del>如果没有就去表单控件里添加id并赋值</del></li></ol><h2 id="select-下拉标签"><a href="#select-下拉标签" class="headerlink" title="select 下拉标签"></a>select 下拉标签</h2><ol><li>作用 点击后展开一个列表 里面的值由option创建<br>也就是在select里加option</li><li>在option里添加属性selected&#x3D;selected 即可设置该option为默认选项</li></ol><h2 id="textarea-文本域"><a href="#textarea-文本域" class="headerlink" title="textarea 文本域"></a>textarea 文本域</h2><ol><li>文本域就是个可以输入多行的文本框</li><li>她有2个属性 cols rows</li><li>cols一行最多多少字</li><li>rows最多多少行<h1 id="emmet语法-补充内容提升开发效率"><a href="#emmet语法-补充内容提升开发效率" class="headerlink" title="emmet语法 (补充内容提升开发效率)"></a>emmet语法 (补充内容<del>提升开发效率</del>)</h1><h2 id="一般情况下打标签需要慢慢打-非常缓慢-下面就会介绍emmet语法快速偷懒"><a href="#一般情况下打标签需要慢慢打-非常缓慢-下面就会介绍emmet语法快速偷懒" class="headerlink" title="一般情况下打标签需要慢慢打 非常缓慢 下面就会介绍emmet语法快速偷懒"></a>一般情况下打标签需要慢慢打 非常缓慢 下面就会介绍emmet语法快速偷懒</h2></li></ol><ul><li>如果想打标签 比如说 &lt; p &gt; &lt; &#x2F;p &gt; 直接写p 然后tab 会自动补全</li><li>如果我想打多个重复的标签 比如说5个&lt; p &gt;&lt; &#x2F;p &gt; 可以直接 p*5 tab补全 会出现5个p段落</li><li>如果想打出很多类似重复的 比如说h1的 我说1 我说2 我说3 我说4 可以 h1{我说$}*5 $是自增从1开始的 {}里面写的是文字</li><li>如果想补全时添加选择器 可以 .类名html标签 或#id名 html标签<br></li></ul><h3 id="ps-自动补全不能有异常空格-比如说-h1-我是不会自动补全的-得h1-我会自动补全-其次光标得在末尾"><a href="#ps-自动补全不能有异常空格-比如说-h1-我是不会自动补全的-得h1-我会自动补全-其次光标得在末尾" class="headerlink" title="ps:自动补全不能有异常空格 比如说 h1 {我是不会自动补全的} 得h1{我会自动补全}   其次光标得在末尾"></a>ps:自动补全不能有异常空格 比如说 h1 {我是不会自动补全的} 得h1{我会自动补全}   其次光标得在末尾</h3>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库创建命令</title>
    <link href="/2022/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="今天学上课学了数据库的常用命令"><a href="#今天学上课学了数据库的常用命令" class="headerlink" title="今天学上课学了数据库的常用命令"></a>今天学上课学了数据库的常用命令</h1><span id="more"></span><h6 id="注释：-包起来的值做修饰作用-部分-中的值可以省略-因为就算不写也默认"><a href="#注释：-包起来的值做修饰作用-部分-中的值可以省略-因为就算不写也默认" class="headerlink" title="注释：[]包起来的值做修饰作用 部分[]中的值可以省略 因为就算不写也默认"></a>注释：[]包起来的值做修饰作用 部分[]中的值可以省略 <del>因为就算不写也默认</del></h6><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>数据库语言不区分大小写</li><li>语句用,隔开</li><li>（）是描述作用域</li><li>mdf是主数据文件后缀</li><li>ndf是次数据文件后缀</li><li>ldf是日志文件的后缀</li><li>逻辑名可以理解为文件名</li><li>物理位置可以理解为完整路径</li><li>主数据文件只有一个</li><li>修改初始大小时只能大不能小<del>这不是废话吗，我存了20M你改成最大14，剩下的6难不成删了吗？</del></li><li>删除文件组必须得是组内无文件时才被允许的</li><li>除了新建数据库时不需要指定数据库 其他操作基本上都得使用 ALTER DATABASE [被指定的数据库名字] 来指定数据库进行操作</li><li>添加和创建都需要添加描述 描述最低得有 NAME AND FILENAME</li></ol><hr><h1 id="数据库设计问题分为四种"><a href="#数据库设计问题分为四种" class="headerlink" title="数据库设计问题分为四种"></a>数据库设计问题分为四种</h1><ul><li>数据更新问题 </li><li>数据插入问题</li><li>数据删除问题</li><li>数据冗余问题</li></ul><h1 id="查看数据库命令"><a href="#查看数据库命令" class="headerlink" title="查看数据库命令"></a>查看数据库命令</h1><h2 id="exec-SP-HELPDB-指定想看的数据库名"><a href="#exec-SP-HELPDB-指定想看的数据库名" class="headerlink" title="[exec] SP_HELPDB [指定想看的数据库名]"></a>[exec] SP_HELPDB [指定想看的数据库名]</h2><h2 id="如果不指定就展示所有数据库"><a href="#如果不指定就展示所有数据库" class="headerlink" title="如果不指定就展示所有数据库"></a>如果不指定就展示所有数据库</h2><h2 id="如果语句是在第一批处理的第一句话-可以省略exec"><a href="#如果语句是在第一批处理的第一句话-可以省略exec" class="headerlink" title="如果语句是在第一批处理的第一句话 可以省略exec"></a>如果语句是在第一批处理的第一句话 可以省略exec</h2><h2 id="如果不是一个批处理的第一个语句就得加exec-或者在前面加GO关键字-让后面的语句成为新的一批"><a href="#如果不是一个批处理的第一个语句就得加exec-或者在前面加GO关键字-让后面的语句成为新的一批" class="headerlink" title="如果不是一个批处理的第一个语句就得加exec 或者在前面加GO关键字 让后面的语句成为新的一批"></a>如果不是一个批处理的第一个语句就得加exec 或者在前面加GO关键字 让后面的语句成为新的一批</h2><hr><h1 id="部分属性"><a href="#部分属性" class="headerlink" title="部分属性"></a>部分属性</h1><ul><li>SIZE 为文件默认的初始大小</li><li>MAXSIZE 为文件最大的大小 <del>这看英文都知道了</del> 如果需要设置为不受限制的 值赋为unlimited</li><li>FILEGROWTH 为增长大小 可以设置百分比</li><li>↑这些计量默认都是MB</li><li>FILE 文件逻辑名 <del>也就是文件名</del></li><li>FILENAME 磁盘文件名 <del>也就是完整路径</del></li><li>NAME 文件名<hr></li></ul><h1 id="部分创建命令"><a href="#部分创建命令" class="headerlink" title="部分创建命令"></a>部分创建命令</h1><ul><li>CREATE DATABASE 数据库名字 创建数据库</li><li>on [PRIMARY] 创建主组PRIMARY 主组无法创建时自定义名字 </li><li>FILEGROUP [次组名] 创建次组</li><li>LOG on 创建日志文件<hr></li></ul><h1 id="部分删除命令"><a href="#部分删除命令" class="headerlink" title="部分删除命令"></a>部分删除命令</h1><ul><li>REMOVE FILE [文件名] 删除文件</li><li>REMOVE FILEGROUP [文件组名] 删除文件组</li><li>DROP DATABASE [数据库名] 删除数据库 <del>删库跑路</del></li></ul><hr><h1 id="部分添加命令"><a href="#部分添加命令" class="headerlink" title="部分添加命令"></a>部分添加命令</h1><ul><li>ADD FILEGROUP [文件组名] 添加文件组</li><li>ADD FILE [文件名] 添加文件 TO FILEGROUP [文件组] 到指定的文件组</li><li>ADD LOG FILE [日志文件名]</li></ul><hr><h1 id="部分修改命令"><a href="#部分修改命令" class="headerlink" title="部分修改命令"></a>部分修改命令</h1><ul><li>MODIFY FILE [被修改的文件名] 修改文件 </li><li>ALTER DATABASE [被修改的数据库名]</li></ul><p><img src="https://s2.loli.net/2022/03/25/bIsm6Q2hFEjgiVl.jpg" alt="乐土猫猫"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL Server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld</title>
    <link href="/2022/03/25/helloWorld/"/>
    <url>/2022/03/25/helloWorld/</url>
    
    <content type="html"><![CDATA[<h1 id="把一切推到重来也许会有不一样的感受"><a href="#把一切推到重来也许会有不一样的感受" class="headerlink" title="把一切推到重来也许会有不一样的感受"></a>把一切推到重来也许会有不一样的感受</h1>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
